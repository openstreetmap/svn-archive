#!/usr/bin/perl

use Getopt::GUI::Long;
use GD;
use POSIX qw(ceil floor);
use XML::Simple;
use Data::Dumper;

my %opts = ();

Getopt::GUI::Long::Configure(qw(display_help no_ignore_case));
GetOptions(\%opts,
	   ["mx|min-x=s", "Minimum Longitude"],
	   ["Mx|max-x=s", "Maximum Longitude"],
	   ["my|min-y=s", "Minimum Latitude"],
	   ["My|may-x=s", "Maximum Latitude"],
	   ["n|number-steps=i", "Number of steps on a side"],
	   ["D|map-data=s", "Map data directory"],

	   ["M|maximum-squares=i", "limit the number of squares to actually perform to M"],
	   ["R|master-rule=s", "XML Master Grid Rule File"],
	   ["O|overview=s", "XML Master Overview Rule File"],
	   ["l|latex-file=s", "Save Figure commands to a latex file"],
	   ["force-fetch",    "Force fetching of new data"],
	   ["ps",             "Expect a postscript generation instead"],
	   ["png",            "Make grid png files"],
	  ) || exit;

#
# read in the project definition file
#
if ($#ARGV != 0) {
    print STDERR "You need to supply a project definition file\n";
    exit(1);
}

my $proj = XMLin($ARGV[0], ForceArray=> ['grid', 'note'], KeyAttr => 'name');
if (!$proj) {
    print STDERR "failed to read in the project file: $ARGV[0]\n";
    exit(1);
}
#print Dumper($proj);
#exit;


#
# map the command line arguments as overrides
#
$proj->{'minlon'}     	       = $opts{'mx'} || $proj->{'minlon'};
$proj->{'maxlon'}     	       = $opts{'Mx'} || $proj->{'maxlon'};
$proj->{'minlat'}     	       = $opts{'my'} || $proj->{'minlat'};
$proj->{'maxlat'}     	       = $opts{'My'} || $proj->{'maxlat'};
$proj->{'datadir'}    	       = $opts{'D'}  || $proj->{'datadir'};
$proj->{'gridwidth'}  	       = $opts{'n'}  || $proj->{'gridwidth'};
$proj->{'grid-rule-file'}      = $opts{'R'}  || $proj->{'grid-rule-file'};
$proj->{'overview-rule-file'}  = $opts{'O'}  || $proj->{'overview-rule-file'};
$proj->{'latex-file'}          = $opts{'l'}  || $proj->{'latex-file'};

my $gridinfo = $proj->{'gridinfo'};
print STDERR Dumper($proj);
print STDERR Dumper($gridinfo);

die "need at least -mx -Mx -my -My and -n\n"
  if (!$proj->{'minlon'} || !$proj->{'maxlon'} || !$proj->{'minlat'} || !$proj->{'maxlat'} || !$proj->{'gridwidth'});

my $diffx = $proj->{'maxlon'} - $proj->{'minlon'};
my $diffy = $proj->{'maxlat'} - $proj->{'minlat'};

# for the number of Y grid squares, use n*y/x but only if it's < P
# n = num x, y/x = map area aspect ration, P = paper aspect ratio (width/height)
# XXX: should round not int; requires a math package
# XXX: or not...  need to default to fitting on the page, which is ceil()
# (more squares)
my $P = 17/20; # arbitrary based on space on the page
my $dydx = $diffy/$diffx;
my $ygridnum = ceil($proj->{'gridwidth'}*$diffy/$diffx);

# if the grid is too tall and will overstretch the Y boundry on the
# page, then keep adding more squares to the Y grid till we fall
# within it.
# IE: we're optimizing for the x-axis since we can control that in latex
print "Y grid guess:   $ygridnum  ($proj->{'gridwidth'}*$diffy/$diffx)\n";
while ($proj->{'gridwidth'}*$dydx/$ygridnum > $P) {
    $ygridnum++;
}
print "Y grid squares: $ygridnum\n";



my $segx = $diffx/$proj->{'gridwidth'};
my $segy = $diffy/$ygridnum;

my @osmfiles;

mkdir ($proj->{'datadir'}) if (! -d $proj->{'datadir'});

my $count;

my $combinedosm  = "$proj->{'datadir'}/combined.osm";
my $combinedsvg  = "$proj->{'datadir'}/combined.svg";
my $combinedpng  = "$proj->{'datadir'}/combined.png";
my $overviewsvg = "$proj->{'datadir'}/overview.svg";
my $overvieweps = "$proj->{'datadir'}/overview.eps";
my $overviewpng = "$proj->{'datadir'}/overview.png";
if ($proj->{'latex-file'}) {
    open(L,">$proj->{'latex-file'}");
    if ($opts{'ps'}) {
	printf L ("\\Overview{$overvieweps}{%s}{%s}{%s}{%s}\n",
		  $proj->{'minlon'},$proj->{'maxlat'},$proj->{'maxlon'},$proj->{'minlat'});
    } else {
	printf L ("\\Overview{$overviewpng}{%s}{%s}{%s}{%s}\n",
		  $proj->{'minlon'},$proj->{'maxlat'},$proj->{'maxlon'},$proj->{'minlat'});
    }
}

my $needoverview = 0;

sub get_grid_num {
    my ($x, $y) = @_;
    return "X" if ($y < 1 || $y > $ygridnum);
    return "X" if ($x < 1 || $x > $proj->{'gridwidth'});

    return (($ygridnum - $y) * $proj->{'gridwidth'} + $x);
}


foreach my $y (reverse(1..$ygridnum)) {
    foreach my $x (1..$proj->{'gridwidth'}) {

	my $gridsquare = get_grid_num($x, $y);

	print "----------------------------------------------------------------------\n";
	print "Starting grid $gridsquare\n";
	print "----------------------------------------------------------------------\n";

	# calculate the bounding box (BB)
	my $minx = $proj->{'minlon'} + ($x-1)*$segx;
	my $miny = $proj->{'minlat'} + ($y-1)*$segy;

	my $maxx = $proj->{'minlon'} + ($x)*$segx;
	my $maxy = $proj->{'minlat'} + ($y)*$segy;
	
	do_grid($gridsquare, $minx, $miny, $maxx, $maxy, $x, $y);
    }
}

#System("osmmerge all.osm ",join(" ",@osmfiles));
# combine all the exsting OSM files into a single combined OSM file
if ($needoverview || ! -f $combinedosm) {

    # create the overview OSM file
    my $cmd = "osmosis/bin/osmosis --read-xml " . 
      join(" --s --merge --read-xml ", @osmfiles) . " --s --merge --write-xml $combinedosm";
    $cmd =~ s/--merge//;
    System($cmd);
}


# build the combined OSM file into a SVG (without the grid)
if (! -f $combinedsvg || Stat($combinedosm, $combinedsvg) ||
    Stat($proj->{'overview-rule-file'}, $combinedsvg)) {

    System("perl orp.svn/orp.pl --minlat $proj->{'minlat'} --maxlat $proj->{'maxlat'} --minlon $proj->{'minlon'} --maxlon $proj->{'maxlon'} -r $proj->{'overview-rule-file'} $combinedosm");
}

# build the overview SVG that contains the grid over the combined OSM
if (! -f $overviewsvg || Stat($combinedsvg, $overviewsvg)) {
    make_overview($overviewsvg, $proj->{'gridwidth'}, $ygridnum,
		  $proj->{'gridwidth'} * 10, $ygridnum * 10, $combinedsvg);
}

# render the overview SVG as EPS for later inclusion into latex
if (! -f $combindepng  ||
    Stat($combinedsvg, $combinedpng)) {
    System("inkscape -f $combinedsvg -e $combinedpng");
#    Stat($overviewsvg, $overvieweps)) {
#    System("inkscape -f $overviewsvg -E $overvieweps");
}

if (! -f $overviewpng  ||
    Stat($combinedpng, $overviewpng)) {
    make_overviewpng($combinedpng, $overviewpng, $proj->{'gridwidth'}, $ygridnum);
}

if ($opts{'ps'}) {
    if (! -f $overvieweps  ||
	Stat($overviewpng, $overvieweps)) {
	#System("convert $overviewpng $overvieweps");
	System("inkscape -f $overviewsvg -E $overvieweps");
    }
}


sub System {
    print join(" ",@_),"\n";
    system(@_);
}

sub do_grid {
    my ($label, $minx, $miny, $maxx, $maxy, $x, $y) = @_;

    my $smosmfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.osm";
    my $osmfile = $smosmfile;
    my $xmlfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.xml";

    if (!$opts{'force-fetch'} && -f $combinedosm) {
	$osmfile = $combinedosm;
    } else {
	if (! -f $osmfile) {
	    System("wget --no-proxy -O $osmfile http://www.openstreetmap.org/api/0.6/map?bbox=$minx,$miny,$maxx,$maxy");
	    $needoverview = 1;
	}

	push @osmfiles, $osmfile;
    }


    # render the page
    if (! -f $xmlfile || Stat($proj->{'grid-rule-file'}, $xmlfile)) {
	print STDERR "creating $xmlfile\n";

	# sigh...  xmlstarlet already assumes the subdir for some reason
	my $starfile = $osmfile;
	$starfile =~ s/$proj->{'datadir'}\///;

	open(I, $proj->{'grid-rule-file'});
	open(O,">$xmlfile");
	while (<I>) {
	    s/data.osm/$osmfile/;
	    #		s/data.osm/$starfile/;
	    print O;
	}
	close(I);
	close(O);
    }

    # render the map as a svg
    my $svgfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.svg";
    if (! -f $svgfile || Stat($xmlfile, $svgfile)) {
	#System("xmlstarlet tr osmarender.xsl $xmlfile > $svgfile");
	System("perl orp.svn/orp.pl --minlat $miny --maxlat $maxy --minlon $minx --maxlon $maxx -r $xmlfile $osmfile");
	if ($osmfile ne $smosmfile) {
	    my $combinedsvg = $osmfile;
	    $combinedsvg =~ s/osm$/svg/;
	    rename($combinedsvg, $svgfile);
	}
    }

    # add a numeric/letter grid border to the svg file
    my $svg2file = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy-gridded.svg";
    # XXX: make optional
    # XXX: make number of grid components on a side optional
    my $extrainkargs = "";
    if (! -f $svg2file || Stat($svgfile, $svg2file)) {
	$extrainkargs = make_svggrid($svgfile, $svg2file);
	$svgfile = $svg2file;
    }

    # convert to png
    # inkscape -f map.svg -e map.png
    my $pngfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.png";
    if ($opts{'png'} && (! -f $pngfile || Stat($svgfile, $pngfile))) {
	System("inkscape -f $svgfile -e $pngfile");
    }

    # convert to eps
    # inkscape -f map.svg -E map.eps
    my $outfile;
    if ($opts{'ps'}) {
	my $epsfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.eps";
	if (! -f $epsfile || Stat($svgfile, $epsfile)) {
	    System("inkscape $extrainkargs -f $svgfile -E $epsfile");
	}
	$outfile = $epsfile;
    } else {
	my $pdffile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.pdf";
	if (! -f $pdffile || Stat($svgfile, $pdffile)) {
	    System("inkscape -f $svgfile -A $pdffile");
	}
	$outfile = $pdffile;
    }

    $count++;
	
    if (defined($proj->{'latex-file'})) {
	# note: y numbers are functionally backwards (bottom to top)
	my $nw = get_grid_num($x-1, $y+1);
	my $n  = get_grid_num($x,   $y+1);
	my $ne = get_grid_num($x+1, $y+1);

	my $w  = get_grid_num($x-1, $y);
	my $e  = get_grid_num($x+1, $y);

	my $sw = get_grid_num($x-1, $y-1);
	my $s  = get_grid_num($x,   $y-1);
	my $se = get_grid_num($x+1, $y-1);

	my $gridstring = "\\Grid{$nw}{$n}{$ne}{$w}{$e}{$sw}{$s}{$se}";

	if ($opts{'ps'}) {
	    print L "\\Map{$outfile}{$label}{$minx}{$maxy}{$maxx}{$miny}{$gridstring}\n";
	} else {
	    print L "\\Map{$outfile}{$label}{$minx}{$maxy}{$maxx}{$miny}{$gridstring}\n";
	}

	if ($#{$gridinfo->{'grid'}{$label}{'note'}} > -1) {
	    print L "\\NotesBegin\n";
	    foreach my $note (@{$gridinfo->{'grid'}{$label}{'note'}}) {
		print STDERR "yay!: $note $gridnum\n";
		print L "\\Note{" . $note . "}\n";
	    }
	    print L "\\NotesEnd\n";
	}
	print L "\\EndPage\n";
    }

    if (defined($opts{'M'}) && $count >= $opts{'M'}) {
	print STDERR "reached maximum\n";
	exit;
    }
}

sub make_overview {
    my ($out, $numx, $numy, $width, $height, $img) = @_;

    use SVG;

    print "Creating $out\n";

    # read in the existing SVG and determine the existing x/y bounds
    open(IIMG, "<$img");
    my $initline = <IIMG>;
    print "looking at $initline\n";
    ($width) = ($initline =~ /width=\"([\.\d]+)px\"/);
    ($height) = ($initline =~ /height=\"([\.\d]+)(|px)\"/);

    open(OSVG, ">$out");
    print OSVG $initline;
    while (<IIMG>) {
	last if (/<\/svg>/);
	print OSVG;
    }

    # add in our grid lines

    my $gridw = $width/$numx;
    my $gridh = $height/$numy;

    print "gridhere: $gridw / $gridh\n";

    # vertical grid lines
    for my $x (0..($numx-1)) {
	print OSVG "<line id=\"vert_$x\" style=\"stroke: rgb(0,0,0)\" x1=\"",
	  $x * $gridw, "\" x2=\"", $x * $gridw, "\" y1=\"0\" y2=\"$height\" />\n";
    }
    print OSVG "<line id=\"vert_last\" style=\"stroke: rgb(0,0,0)\" x1=\"$gridw\"",
      " x2=\"$gridw\" y1=\"0\" y2=\"$height\" />\n";

    # vertical grid lines
    for my $y (0..($numy-1)) {
	print OSVG "<line id=\"horz_$y\" style=\"stroke: rgb(0,0,0)\" y1=\"",
	  $y * $gridh, "\" y2=\"", $y * $gridh, "\" x1=\"0\" x2=\"$width\" />\n";
    }
    print OSVG "<line id=\"horz_last\" style=\"stroke: rgb(0,0,0)\" y1=\"$gridh\"",
      " y2=\"$gridh\" x1=\"0\" x2=\"$width\" />\n";

    my $textstyle = "style=\"font-size: " . int($gridw/4) . "px;\"";

    # grid square labels
    for my $x (0..($numx-1)) {
	for my $y (0..($numy-1)) {
	    print OSVG "<text $textstyle x=\"", $x*$gridw + $gridw/2, "\" y=\"",
	      $y*$gridh + $gridh/2, "\">", $y*$numx + $x + 1, "</text>\n";
	}
    }

    print OSVG "</svg>\n";
}

sub make_svggrid {
    my ($infile, $outfile) = @_;
    open(I, $infile);
    open(O, ">$outfile");

    my $hsize = .03;
    my $vsize = .03;

    my $numx = 9;
    my $numy = 9;
    my @xlabels = (1..100);
    my @ylabels = ('A' .. 'Z');

    print "modifying SVG to add grids\n";

    # extract the width/height and bourdary box of the original image
    # so we know how much to scale it by.
    my $initline = <I>;

    my ($origwidth, $origheight);
    ($origwidth) = ($initline =~ /width=\"([\.\d]+)px\"/);
    ($origheight) = ($initline =~ /height=\"([\.\d]+)(|px)\"/);

    my $width = $origwidth * (1 + $hsize);
    my $height = $origheight * (1 + $vsize);

    $initline =~ s/(width=\")([\.\d]+)(px\")/$1$width$3/;
    $initline =~ s/(height=\")([\.\d]+)(px\")/$1$height$3/;
    $initline =~ s/(viewBox=\"[-\.\d]+\s+[-\.\d]+\s+)[^\"]+/$1$width $height/;

    # print out modified the first line
    print O $initline;

    # dump the rest of the file out
    while (<I>) {
	last if (/<\/svg>/);

	# make the background bigger
	# XXX: assumes height comes first on line
	s/(<rect.*height=\")([^"]+)(\".*width=\")([^"]+)(\".*class=\"map-background\".*)/$1$height$3$width$5/;

	print O $_;
    }

    # add in our own side grid lines

    my $vlinetop = $height - $origheight * $vsize;
    my $vlinegap = $origwidth / $numx;
    my $hlinetop = $width - $origwidth * $hsize;
    my $hlinegap = $origheight / $numx;
    my $textstyle = "style=\"font-size: " . int($vlinegap/4) . "px;\"";


    # add a blank white square underneath
    print O "<rect id=\"marginalia-background\" x=\"0px\" y=\"$origheight\" height=\"${hlinegap}px\" width=\"${width}px\" class=\"map-marginalia-background\" />\n";
    print O "<rect id=\"marginalia-background\" x=\"${origwidth}px\" y=\"0\" height=\"${height}px\" width=\"${vlinegap}px\" class=\"map-marginalia-background\" />\n";

    # outer black lines
    # horizontal
    print O "<line style=\"stroke: rgb(0,0,0)\" x1=\"1\" x2=\"$width\" y1=\"1\" y2=\"1\" />\n";
    print O "<line style=\"stroke: rgb(0,0,0)\" x1=\"1\" x2=\"$width\" y1=\"$vlinetop\" y2=\"$vlinetop\" />\n";
    print O "<line style=\"stroke: rgb(0,0,0)\" x1=\"1\" x2=\"$width\" y1=\"" . ($height-1) . "\" y2=\"" . ($height-1) . "\" />\n";

    # vertical
    print O "<line style=\"stroke: rgb(0,0,0)\" x1=\"1\" x2=\"1\" y1=\"1\" y2=\"$height\" />\n";
    print O "<line style=\"stroke: rgb(0,0,0)\" x1=\"$hlinetop\" x2=\"$hlinetop\" y1=\"1\" y2=\"$height\" />\n";
    print O "<line style=\"stroke: rgb(0,0,0)\" x1=\"" . ($width-1) . "\" x2=\"" . ($width-1) . "\" y1=\"1\" y2=\"$height\" />\n";


    # vertical grid lines and horizontal labels
    for my $x (0..($numx)) {
	print O "<line style=\"stroke: rgb(0,0,0)\" x1=\"",
	  $x * $vlinegap, "\" x2=\"", $x * $vlinegap, 
	    "\" y1=\"$vlinetop\" y2=\"$height\" />\n";
	if ($x != $numx) {
	    print O "<text $textstyle x=\"", $x*$vlinegap + $vlinegap/2,
	      "\" y=\"", $height - $hlinegap/16, "\">",
		$xlabels[$x], "</text>\n";
	}
    }

    # horizontal grid lines and virtical labels
    for my $y (0..($numy)) {
	print O "<line style=\"stroke: rgb(0,0,0)\" y1=\"",
	  $y * $hlinegap, "\" y2=\"", $y * $hlinegap, 
	    "\" x1=\"$hlinetop\" x2=\"$width\" />\n";
	if ($y != $numy) {
	    print O "<text $textstyle y=\"", $y*$hlinegap + $hlinegap/2,
	      "\" x=\"", $width - $vlinegap/4, "\">",
		$ylabels[$y], "</text>\n";
	}
    }

    print O "</svg>\n";
    close(I);
    close(O);

    return "-a 0:0:$width:$height";
}


sub make_overviewpng {
    my ($inpng, $outpng, $numx, $numy) = @_;

    print "Creating $outpng\n";

    my $overviewimg = GD::Image->newFromPng($inpng, 1);
    die ("couldn't open/create $combinedpng") if (!$overviewimg);
    my ($width, $height) = $overviewimg->getBounds();


    my $black = $overviewimg->colorAllocate(32,32,32);
    my $gridw = $width/$numx;
    my $gridh = $height/$numy;

    my $linewidth = int($width/400) || 1;

    # vertical grid lines
    for my $x (0..$numx) {
	$overviewimg->filledRectangle(int($x*$gridw)-$linewidth, 0,
				      int($x*$gridw)+$linewidth, $height,
				      $black);
    }

    # horizontal grid lines
    for my $y (0..$numy) {
	$overviewimg->filledRectangle(0,      int($y*$gridh)-$linewidth,
				      $width, int($y*$gridh)+$linewidth,
				      $black);
    }

    # grid square labels
    for my $x (0..($numx-1)) {
	for my $y (0..($numy-1)) {
# 	    $overviewimg->string(gdGiantFont,
# 				 int($x*$gridw + $gridw/2),
# 				 int($y*$gridh + $gridh/2),
# 				 $y*$numx + $x + 1,
# 				 $black);
 	    $overviewimg->stringFT($black, '/home/hardaker/docs/ham/maps/LiberationMono-Bold.ttf',
				   int($width/30), 0,
				   int($x*$gridw + $gridw/2),
				   int($y*$gridh + $gridh/2),
				   $y*$numx + $x + 1);
	}
    }

    # save the results
    open(OPNG, ">$outpng");
    print OPNG $overviewimg->png;
    close(OPNG);
}


# returns true if the timestamp from file ARG1 is newer than file ARG2
sub Stat {
    my ($file1, $file2) = @_;
    my @attr1 = stat $file1;
    my @attr2 = stat $file2;
#    print STDERR "newer: $file1\n" if ($attr1[9] > $attr2[9]);
#    print STDERR "newer: $file2\n" if ($attr1[9] <= $attr2[9]);
    return $attr1[9] > $attr2[9];
}


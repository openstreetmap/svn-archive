#!/usr/bin/perl

use IO::File;
use Getopt::GUI::Long;
use GD;
use POSIX qw(ceil floor);
use XML::Simple;
use Data::Dumper;
use strict;

my %opts = ();

Getopt::GUI::Long::Configure(qw(display_help no_ignore_case));
GetOptions(\%opts,
	   ["mx|min-x=s", "Minimum Longitude"],
	   ["Mx|max-x=s", "Maximum Longitude"],
	   ["my|min-y=s", "Minimum Latitude"],
	   ["My|may-x=s", "Maximum Latitude"],
	   ["n|number-steps=i", "Number of steps on a side"],
	   ["D|map-data=s", "Map data directory"],

	   ["M|maximum-squares=i", "limit the number of squares to actually perform to M"],
	   ["R|master-rule=s", "XML Master Grid Rule File"],
	   ["O|overview=s", "XML Master Overview Rule File"],
	   ["l|latex-file=s", "Save Figure commands to a latex file"],
	   ["force-fetch",    "Force fetching of new data"],
	   ["ps",             "Expect a postscript generation instead"],
	   ["png",            "Make grid png files"],
	   ["svg",            "Make fully rendered SVG pages"],
	  ) || exit;

#
# read in the project definition file
#
if ($#ARGV != 0) {
    print STDERR "You need to supply a project definition file\n";
    exit(1);
}

my $proj = XMLin($ARGV[0], ForceArray=> ['grid', 'note'], KeyAttr => 'name');
if (!$proj) {
    print STDERR "failed to read in the project file: $ARGV[0]\n";
    exit(1);
}
#print Dumper($proj);
#exit;


#
# map the command line arguments as overrides
#
$proj->{'minlon'}     	       = $opts{'mx'} || $proj->{'minlon'};
$proj->{'maxlon'}     	       = $opts{'Mx'} || $proj->{'maxlon'};
$proj->{'minlat'}     	       = $opts{'my'} || $proj->{'minlat'};
$proj->{'maxlat'}     	       = $opts{'My'} || $proj->{'maxlat'};
$proj->{'datadir'}    	       = $opts{'D'}  || $proj->{'datadir'};
$proj->{'gridwidth'}  	       = $opts{'n'}  || $proj->{'gridwidth'};
$proj->{'grid-rule-file'}      = $opts{'R'}  || $proj->{'grid-rule-file'};
$proj->{'subgrid-rule-file'}   = $opts{'S'}  || $proj->{'subgrid-rule-file'} ||
                                 $proj->{'grid-rule-file'};
$proj->{'overview-rule-file'}  = $opts{'O'}  || $proj->{'overview-rule-file'};
$proj->{'latex-file'}          = $opts{'l'}  || $proj->{'latex-file'};

my $gridinfo = $proj->{'gridinfo'};
#print STDERR Dumper($proj);
#print STDERR Dumper($gridinfo);

die "need at least -mx -Mx -my -My and -n\n"
  if (!$proj->{'minlon'} || !$proj->{'maxlon'} || !$proj->{'minlat'} || !$proj->{'maxlat'} || !$proj->{'gridwidth'});

my $diffx = $proj->{'maxlon'} - $proj->{'minlon'};
my $diffy = $proj->{'maxlat'} - $proj->{'minlat'};

# for the number of Y grid squares, use n*y/x but only if it's < P
# n = num x, y/x = map area aspect ration, P = paper aspect ratio (width/height)
# XXX: should round not int; requires a math package
# XXX: or not...  need to default to fitting on the page, which is ceil()
# (more squares)
my $P = 17/20; # arbitrary based on space on the page
my $dydx = $diffy/$diffx;
my $ygridnum = ceil($proj->{'gridwidth'}*$diffy/$diffx);

# if the grid is too tall and will overstretch the Y boundry on the
# page, then keep adding more squares to the Y grid till we fall
# within it.
# IE: we're optimizing for the x-axis since we can control that in latex
DEBUG("Y grid guess:   $ygridnum  ($proj->{'gridwidth'}*$diffy/$diffx)\n");
while ($proj->{'gridwidth'}*$dydx/$ygridnum > $P) {
    $ygridnum++;
}
DEBUG("Y grid squares: $ygridnum\n");

my $segx = $diffx/$proj->{'gridwidth'};
my $segy = $diffy/$ygridnum;

my @osmfiles;

mkdir ($proj->{'datadir'}) if (! -d $proj->{'datadir'});

my $count;

my $combinedosm  = "$proj->{'datadir'}/combined.osm";
my $combinedsvg  = "$proj->{'datadir'}/combined.svg";
my $combinedpng  = "$proj->{'datadir'}/combined.png";
my $overviewsvg = "$proj->{'datadir'}/overview.svg";
my $overvieweps = "$proj->{'datadir'}/overview.eps";
my $overviewpng = "$proj->{'datadir'}/overview.png";
if ($proj->{'latex-file'}) {
    open(L,">$proj->{'latex-file'}");
    if ($opts{'ps'}) {
	printf L ("\\Overview{$overvieweps}{%s}{%s}{%s}{%s}\n",
		  $proj->{'minlon'},$proj->{'maxlat'},$proj->{'maxlon'},$proj->{'minlat'});
    } else {
	printf L ("\\Overview{$overviewpng}{%s}{%s}{%s}{%s}\n",
		  $proj->{'minlon'},$proj->{'maxlat'},$proj->{'maxlon'},$proj->{'minlat'});
    }
}

my $needoverview = 0;

######################################################################
# Build each grid square
#
foreach my $y (reverse(1..$ygridnum)) {
    foreach my $x (1..$proj->{'gridwidth'}) {

	my $gridsquare = get_grid_num($x, $y);

	next if ($gridinfo->{'grid'}{$gridsquare}{'skip'});

	DEBUG("----------------------------------------------------------------------\n");
	DEBUG("Starting grid $gridsquare\n");
	DEBUG("----------------------------------------------------------------------\n");

	# calculate the bounding box (BB)
	my $minx = $proj->{'minlon'} + ($x-1)*$segx;
	my $miny = $proj->{'minlat'} + ($y-1)*$segy;

	my $maxx = $proj->{'minlon'} + ($x)*$segx;
	my $maxy = $proj->{'minlat'} + ($y)*$segy;
	
	if ($gridinfo->{'grid'}{$gridsquare}{'subgrid'}) {
	    my $numsubx = $gridinfo->{'grid'}{$gridsquare}{'subgrid'};
	    my $numsuby = $gridinfo->{'grid'}{$gridsquare}{'subgrid'};
	    foreach my $suby (reverse(0..($numsuby-1))) {
		foreach my $subx (0..($numsubx-1)) {
		    my $newminx = $minx + $subx * ($maxx-$minx)/$numsubx;
		    my $newminy = $miny + $suby * ($maxy-$miny)/$numsuby;

		    my $newmaxx = $minx + ($subx+1) * ($maxx-$minx)/$numsubx;
		    my $newmaxy = $miny + ($suby+1) * ($maxy-$miny)/$numsuby;

		    do_grid("$gridsquare-" . get_grid_num($subx+1, $suby+1,
							  $numsubx, $numsuby),
			    $newminx, $newminy,
			    $newmaxx, $newmaxy, $x, $y,
			    $proj->{'subgrid-rule-file'});
		}
	    }
	} else {
	    do_grid($gridsquare, $minx, $miny, $maxx, $maxy, $x, $y);
	}
    }
}

######################################################################
# Now build the overall combined overview map
#

# combine all the exsting OSM files into a single combined OSM file
if ($needoverview || ! -f $combinedosm) {

    # create the overview OSM file
    my $cmd = "osmosis/bin/osmosis --read-xml " . 
      join(" --s --merge --read-xml ", @osmfiles) . " --s --merge --write-xml $combinedosm";
    $cmd =~ s/--merge//;
    System($cmd);
}


# build the combined OSM file into a SVG (without the grid)
if (! -f $combinedsvg || Stat($combinedosm, $combinedsvg) ||
    Stat($proj->{'overview-rule-file'}, $combinedsvg)) {

    System("perl orp.svn/orp.pl --minlat $proj->{'minlat'} --maxlat $proj->{'maxlat'} --minlon $proj->{'minlon'} --maxlon $proj->{'maxlon'} -r $proj->{'overview-rule-file'} $combinedosm");
}

# build the overview SVG that contains the grid over the combined OSM
if (! -f $overviewsvg || Stat($combinedsvg, $overviewsvg)) {
    make_overview($overviewsvg, $proj->{'gridwidth'}, $ygridnum,
		  $proj->{'gridwidth'} * 10, $ygridnum * 10, $combinedsvg);
}

# render the overview SVG as EPS for later inclusion into latex
if (! -f $combinedpng  ||
    Stat($combinedsvg, $combinedpng)) {
    System("inkscape -f $combinedsvg -e $combinedpng");
#    Stat($overviewsvg, $overvieweps)) {
#    System("inkscape -f $overviewsvg -E $overvieweps");
}

if (! -f $overviewpng  ||
    Stat($combinedpng, $overviewpng)) {
    make_overviewpng($combinedpng, $overviewpng, $proj->{'gridwidth'}, $ygridnum);
}

# export to postscript
if ($opts{'ps'}) {
    if (! -f $overvieweps  ||
	Stat($overviewpng, $overvieweps)) {
	#System("convert $overviewpng $overvieweps");
	System("inkscape -f $overviewsvg -E $overvieweps");
    }
}

######################################################################
# subroutines
#

sub get_grid_num {
    my ($x, $y, $numsubx, $numsuby) = @_;

    $numsubx ||= $proj->{'gridwidth'};
    $numsuby ||= $ygridnum;

    return "X" if ($y < 1 || $y > $numsuby);
    return "X" if ($x < 1 || $x > $numsubx);

    return (($numsuby - $y) * $numsubx + $x);
}

#
# converts a x,y grid square into a printable form of a grid square
#
# (in particular, it knows how to print sub-grid formatted squares)
#
sub get_grid_display_num {
    my ($x, $y, $format) = @_;
    $format ||= 'latex';

    my $gridnum = get_grid_num($x, $y);

    return $gridnum if ($gridnum eq "X");

    # if a sub-grid, return it as a latex table
    if ($gridinfo->{'grid'}{$gridnum}{'subgrid'}) {
	my $numsubs = $gridinfo->{'grid'}{$gridnum}{'subgrid'};
	if ($format eq 'latex') {
	    # latex style output
	    my $out = "\\begin{tiny}\n";
	    $out   .= "\\begin{tabular}{" . "c|" x $numsubs . "}\n";
	    $out =~ s/\|}\n$/}\n/;

	    foreach my $yn (1 .. $numsubs) {
		foreach my $xn (1 .. $numsubs) {
		    $out .= $gridnum . "-" . ($numsubs*($yn-1) + $xn) . " & ";
		}
		$out =~ s/\& $/\\\\\n\\hline\n/;
	    }
	    $out =~ s/\\hline\n$//m;
	    $out .= "\\end{tabular}\n";
	    $out .= "\\end{tiny}\n";
	    return $out;
	} else {
	    # svn style output
	    my $out = "XXX";
	    return $out;
	}
    }

    # return the original singual grid square
    return $gridnum;
}

#
# actually render a particular grid square
#
sub do_grid {
    my ($label, $minx, $miny, $maxx, $maxy, $x, $y, $rulefile) = @_;

    $rulefile ||= $proj->{'grid-rule-file'};

    my $smosmfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.osm";
    my $osmfile = $smosmfile;
    my $xmlfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.xml";

    if (!$opts{'force-fetch'} && -f $combinedosm) {
	$osmfile = $combinedosm;
    } else {
	if (! -f $osmfile) {
	    System("wget --no-proxy -O $osmfile http://www.openstreetmap.org/api/0.6/map?bbox=$minx,$miny,$maxx,$maxy");
	    $needoverview = 1;
	}

	push @osmfiles, $osmfile;
    }


    # render the page
    if (! -f $xmlfile || Stat($rulefile, $xmlfile)) {
	DEBUG("creating $xmlfile\n");

	# sigh...  xmlstarlet already assumes the subdir for some reason
	my $starfile = $osmfile;
	$starfile =~ s/$proj->{'datadir'}\///;

	open(I, $rulefile);
	open(O,">$xmlfile");
	while (<I>) {
	    s/data.osm/$osmfile/;
	    #		s/data.osm/$starfile/;
	    print O;
	}
	close(I);
	close(O);
    }

    # render the map as a svg
    my $svgfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.svg";
    if (! -f $svgfile || Stat($xmlfile, $svgfile)) {
	#System("xmlstarlet tr osmarender.xsl $xmlfile > $svgfile");
	System("perl orp.svn/orp.pl --minlat $miny --maxlat $maxy --minlon $minx --maxlon $maxx -r $xmlfile $osmfile");
	if ($osmfile ne $smosmfile) {
	    my $combinedsvg = $osmfile;
	    $combinedsvg =~ s/osm$/svg/;
	    rename($combinedsvg, $svgfile);
	}
    }

    # add a numeric/letter grid border to the svg file
    my $svg2file = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy-gridded.svg";
    # XXX: make optional
    # XXX: make number of grid components on a side optional
    my $extrainkargs = "";
    if (! -f $svg2file || Stat($svgfile, $svg2file)) {
	$extrainkargs = make_svggrid($svgfile, $svg2file);
	$svgfile = $svg2file;
    }

    # convert to png
    # inkscape -f map.svg -e map.png
    my $pngfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.png";
    if ($opts{'png'} && (! -f $pngfile || Stat($svgfile, $pngfile))) {
	System("inkscape -f $svgfile -e $pngfile");
    }

    # convert to eps
    # inkscape -f map.svg -E map.eps
    my $outfile;
    if ($opts{'ps'}) {
	my $epsfile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.eps";
	if (! -f $epsfile || Stat($svgfile, $epsfile)) {
	    System("inkscape $extrainkargs -f $svgfile -E $epsfile");
	}
	$outfile = $epsfile;
    } else {
	my $pdffile = "$proj->{'datadir'}/mapdata-$minx-$maxx-$miny-$maxy.pdf";
	if (! -f $pdffile || Stat($svgfile, $pdffile)) {
	    System("inkscape -f $svgfile -A $pdffile");
	}
	$outfile = $pdffile;
    }

    $count++;
	
    if (defined($proj->{'latex-file'})) {
	# note: y numbers are functionally backwards (bottom to top)
	my $nw = get_grid_display_num($x-1, $y+1);
	my $n  = get_grid_display_num($x,   $y+1);
	my $ne = get_grid_display_num($x+1, $y+1);

	my $w  = get_grid_display_num($x-1, $y);
	my $here = get_grid_display_num($x, $y);
	my $e  = get_grid_display_num($x+1, $y);

	my $sw = get_grid_display_num($x-1, $y-1);
	my $s  = get_grid_display_num($x,   $y-1);
	my $se = get_grid_display_num($x+1, $y-1);

	my $gridstring = "\\Grid{$nw}{$n}{$ne}{$w}{$here}{$e}{$sw}{$s}{$se}";

	if ($opts{'ps'}) {
	    print L "\\Map{$outfile}{$label}{$minx}{$maxy}{$maxx}{$miny}{$gridstring}\n";
	} else {
	    print L "\\Map{$outfile}{$label}{$minx}{$maxy}{$maxx}{$miny}{$gridstring}\n";
	}

	if ($#{$gridinfo->{'grid'}{$label}{'note'}} > -1) {
	    print L "\\NotesBegin\n";
	    foreach my $note (@{$gridinfo->{'grid'}{$label}{'note'}}) {
		print L "\\Note{" . $note . "}\n";
	    }
	    print L "\\NotesEnd\n";
	}
	print L "\\EndPage\n";
    }

    if (defined($opts{'M'}) && $count >= $opts{'M'}) {
	print STDERR "reached maximum\n";
	exit;
    }
}

sub make_overview {
    my ($out, $numx, $numy, $width, $height, $img) = @_;

    use SVG;

    DEBUG("Creating $out\n");

    # read in the existing SVG and determine the existing x/y bounds
    open(IIMG, "<$img");
    my $initline = <IIMG>;
    ($width) = ($initline =~ /width=\"([\.\d]+)px\"/);
    ($height) = ($initline =~ /height=\"([\.\d]+)(|px)\"/);

    open(OSVG, ">$out");
    print OSVG $initline;
    while (<IIMG>) {
	last if (/<\/svg>/);
	print OSVG;
    }

    # add in our grid lines

    my $gridw = $width/$numx;
    my $gridh = $height/$numy;

    make_overview_grid($gridw, $gridh, $width, $height ,0, 0, $numx, $numy, "");
    print OSVG "</svg>\n";
}

#
# gridw/gridh = size of each grid square
# width/height = total size of grid area
# woffset, hoffset = offset into range where grid is located (ie, base)
# numx/numy = number of grid squares in x and y space to draw
# prefix = prefix to prepend to label
#
sub make_overview_grid {
    my ($gridw, $gridh, $width, $height, $woffset, $hoffset,
	$numx, $numy, $prefix) = @_;

    # vertical grid lines
    for my $x (0..($numx-1)) {
	print OSVG "<line id=\"vert_$prefix$x\" style=\"stroke: rgb(0,0,0)\" x1=\"",
	  ($woffset + $x * $gridw), "\" x2=\"", ($woffset + $x * $gridw),
	    "\" y1=\"$hoffset\" y2=\"", ($hoffset + $height), "\" />\n";
    }

    print OSVG "<line id=\"vert_${prefix}last\" style=\"stroke: rgb(0,0,0)\" x1=\"",
      ($woffset + $width), "\"",
	" x2=\"", ($woffset + $width), "\" y1=\"$hoffset\" y2=\"",
	  ($hoffset + $height), "\" />\n";

    # horizontal grid lines
    for my $y (0..($numy-1)) {
	print OSVG "<line id=\"horz_$prefix$y\" style=\"stroke: rgb(0,0,0)\" y1=\"",
	  ($hoffset + $y * $gridh), "\" y2=\"",
	    ($hoffset + $y * $gridh), "\" x1=\"", ($woffset), "\" x2=\"",
	      ($woffset + $width), "\" />\n";
    }

    print OSVG "<line id=\"horz_${prefix}last\" style=\"stroke: rgb(0,0,0)\" y1=\"",
      ($hoffset + $height), "\"",
	" y2=\"", ($hoffset + $height), "\" x1=\"$woffset\" x2=\"",
	  ($woffset + $width), "\" />\n";

    my $textstyle = "style=\"font-size: " . int($gridw/4) . "px;\"";

    # grid square labels
    for my $x (0..($numx-1)) {
	for my $y (0..($numy-1)) {
	    my $gridsquare = $y*$numx + $x + 1;
	    next if ($gridinfo->{'grid'}{$gridsquare}{'skip'});
	    if (!$prefix &&
		$gridinfo->{'grid'}{$gridsquare}{'subgrid'}) {
		my $subnum = $gridinfo->{'grid'}{$gridsquare}{'subgrid'};
		make_overview_grid($gridw/$subnum, $gridh/$subnum,
				   $gridw, $gridh,
				   $x*$gridw, $y*$gridh,
				   $subnum, $subnum,
				   ($y*$numx + $x + 1) . "-")
	    } else {
		print OSVG "<text $textstyle x=\"",
		  $woffset + $x*$gridw + $gridw/3,
		  "\" y=\"", $hoffset + $y*$gridh + $gridh/2, "\">$prefix",
		    $y*$numx + $x + 1, "</text>\n";
	    }
	}
    }

}

# it's generally faster to read straight SVG files as text than completely
# parse them; so because we're really just taking one file and adding data
# we don't pull in the full SVG to parse and just copy it till the end
# but remembering the bounding area size

sub copy_svg {
    my ($infile, $outfile, $hscale, $vscale) = @_;

    $hscale ||= 1;
    $vscale ||= 1;

    DEBUG("copying (augmenting?) SVG $infile to SVG $outfile\n");

    my $inh = new IO::File;
    $inh->open("<$infile");

    my $outh = new IO::File;
    $outh->open(">$outfile");

    # find the width/height spec
    my $initline = <$inh>;

    # find original width/height
    my ($origwidth, $origheight);
    ($origwidth) = ($initline =~ /width=\"([\.\d]+)px\"/);
    ($origheight) = ($initline =~ /height=\"([\.\d]+)(|px)\"/);

    # scale the canvas as requested
    my $width = $origwidth * $hscale;
    my $height = $origheight * $vscale;

    # and put out the new scale
    print "here: $initline\n";
    $initline =~ s/(width=\")([\.\d]+)(px\")/$1$width$3/;
    $initline =~ s/(height=\")([\.\d]+)(px\")/$1$height$3/;
    $initline =~ s/(viewBox=\"[-\.\d]+\s+[-\.\d]+\s+)[^\"]+/$1$width $height/;

    print "here: $initline\n";

    $outh->print($initline);

    # copy everything but the closing svg line to the new file
    while (<$inh>) {
	last if (/<\/svg>/);

	# make the background bigger
	# XXX: assumes height comes first on line
	s/(<rect.*height=\")([^"]+)(\".*width=\")([^"]+)(\".*class=\"map-background\".*)/$1$height$3$width$5/;

	print $outh $_;
    }

    $inh->close();

    return ($outh, $width, $height, $origwidth, $origheight);
}

sub make_svggrid {
    my ($infile, $outfile) = @_;

    my $hsize = .03;
    my $vsize = .03;

    my $numx = 9;
    my $numy = 9;
    my @xlabels = (1..100);
    my @ylabels = ('A' .. 'Z');

    DEBUG("modifying SVG to add grids\n");

    my ($outh, $width, $height, $origwidth, $origheight) =
      copy_svg($infile, $outfile, 1+$hsize, 1+$vsize);

    # add in our own side grid lines

    my $vlinetop = $height - $origheight * $vsize;
    my $vlinegap = $origwidth / $numx;
    my $hlinetop = $width - $origwidth * $hsize;
    my $hlinegap = $origheight / $numx;
    my $textstyle = "style=\"font-size: " . int($vlinegap/4) . "px;\"";


    # add a blank white square underneath
    print $outh "<rect id=\"marginalia-background\" x=\"0px\" y=\"$origheight\" height=\"${hlinegap}px\" width=\"${width}px\" class=\"map-marginalia-background\" />\n";
    print $outh "<rect id=\"marginalia-background\" x=\"${origwidth}px\" y=\"0\" height=\"${height}px\" width=\"${vlinegap}px\" class=\"map-marginalia-background\" />\n";

    # outer black lines
    # horizontal
    print $outh "<line style=\"stroke: rgb(0,0,0)\" x1=\"1\" x2=\"$width\" y1=\"1\" y2=\"1\" />\n";
    print $outh "<line style=\"stroke: rgb(0,0,0)\" x1=\"1\" x2=\"$width\" y1=\"$vlinetop\" y2=\"$vlinetop\" />\n";
    print $outh "<line style=\"stroke: rgb(0,0,0)\" x1=\"1\" x2=\"$width\" y1=\"" . ($height-1) . "\" y2=\"" . ($height-1) . "\" />\n";

    # vertical
    print $outh "<line style=\"stroke: rgb(0,0,0)\" x1=\"1\" x2=\"1\" y1=\"1\" y2=\"$height\" />\n";
    print $outh "<line style=\"stroke: rgb(0,0,0)\" x1=\"$hlinetop\" x2=\"$hlinetop\" y1=\"1\" y2=\"$height\" />\n";
    print $outh "<line style=\"stroke: rgb(0,0,0)\" x1=\"" . ($width-1) . "\" x2=\"" . ($width-1) . "\" y1=\"1\" y2=\"$height\" />\n";


    # vertical grid lines and horizontal labels
    for my $x (0..($numx)) {
	print $outh "<line style=\"stroke: rgb(0,0,0)\" x1=\"",
	  $x * $vlinegap, "\" x2=\"", $x * $vlinegap, 
	    "\" y1=\"$vlinetop\" y2=\"$height\" />\n";
	if ($x != $numx) {
	    print $outh "<text $textstyle x=\"", $x*$vlinegap + $vlinegap/2,
	      "\" y=\"", $height - $hlinegap/16, "\">",
		$xlabels[$x], "</text>\n";
	}
    }

    # horizontal grid lines and virtical labels
    for my $y (0..($numy)) {
	print $outh "<line style=\"stroke: rgb(0,0,0)\" y1=\"",
	  $y * $hlinegap, "\" y2=\"", $y * $hlinegap, 
	    "\" x1=\"$hlinetop\" x2=\"$width\" />\n";
	if ($y != $numy) {
	    print $outh "<text $textstyle y=\"", $y*$hlinegap + $hlinegap/2,
	      "\" x=\"", $width - $vlinegap/4, "\">",
		$ylabels[$y], "</text>\n";
	}
    }

    print $outh "</svg>\n";
    $outh->close();

    return "-a 0:0:$width:$height";
}


sub make_overviewpng {
    my ($inpng, $outpng, $numx, $numy) = @_;

    DEBUG("Creating $outpng\n");

    my $overviewimg = GD::Image->newFromPng($inpng, 1);
    die ("couldn't open/create $combinedpng") if (!$overviewimg);
    my ($width, $height) = $overviewimg->getBounds();


    my $black = $overviewimg->colorAllocate(32,32,32);
    my $gridw = $width/$numx;
    my $gridh = $height/$numy;

    my $linewidth = int($width/400) || 1;

    # vertical grid lines
    for my $x (0..$numx) {
	$overviewimg->filledRectangle(int($x*$gridw)-$linewidth, 0,
				      int($x*$gridw)+$linewidth, $height,
				      $black);
    }

    # horizontal grid lines
    for my $y (0..$numy) {
	$overviewimg->filledRectangle(0,      int($y*$gridh)-$linewidth,
				      $width, int($y*$gridh)+$linewidth,
				      $black);
    }

    # grid square labels
    for my $x (0..($numx-1)) {
	for my $y (0..($numy-1)) {
# 	    $overviewimg->string(gdGiantFont,
# 				 int($x*$gridw + $gridw/2),
# 				 int($y*$gridh + $gridh/2),
# 				 $y*$numx + $x + 1,
# 				 $black);
 	    $overviewimg->stringFT($black, '/home/hardaker/docs/ham/maps/LiberationMono-Bold.ttf',
				   int($width/30), 0,
				   int($x*$gridw + $gridw/2),
				   int($y*$gridh + $gridh/2),
				   $y*$numx + $x + 1);
	}
    }

    # save the results
    open(OPNG, ">$outpng");
    print OPNG $overviewimg->png;
    close(OPNG);
}

########################################
# utility routines
#

# returns true if the timestamp from file ARG1 is newer than file ARG2
sub Stat {
    my ($file1, $file2) = @_;
    my @attr1 = stat $file1;
    my @attr2 = stat $file2;
#    print STDERR "newer: $file1\n" if ($attr1[9] > $attr2[9]);
#    print STDERR "newer: $file2\n" if ($attr1[9] <= $attr2[9]);
    return $attr1[9] > $attr2[9];
}

sub System {
    print join(" ",@_),"\n";
    system(@_);
}

sub DEBUG {
    # XXX: make output optional
    print join(" ",@_),"\n";
}

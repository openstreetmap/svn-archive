#!/usr/bin/perl
# mapfeatures.pl - Rebuilds the mapfeatures.xml maplint test file
# Copyright (C) 2007 Knut Arne BjÃ¸rndal
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Usage:
# $ ./tests/strict/not-in-map_features.pl > tests/strict/not-in-map_features.xml.new
# $ diff -u tests/strict/not-in-map_features.xml tests/strict/not-in-map_features.xml.new
# Make sure to look over the diff and check that not too much has changed.
# That could be a sign that somebody has radically changed the format of
# Map Features or something.
# If it looks fine, then do:
# $ mv tests/strict/not-in-map_features.xml.new tests/strict/not-in-map_features.xml
# And build maplint as usual

use strict;
use warnings;

use Geo::OSM::MapFeatures;

sub add_feature( $$$ );

# Get export of Map_Features
my $mf = new Geo::OSM::MapFeatures;
$mf->trace(1);
unless( $ENV{MAPFEATURESDEBUG} ){
    $mf->download();
} else {
    $mf->debug_download();
}

$mf->parse();

foreach my $feature ( $mf->features() ){
    foreach my $value ( @{ $feature->values() } ){
        add_feature($feature->key(), $value, $feature->types());
    }
}

# Add some additional features
add_feature('osmarender:nameDirection', new Geo::OSM::MapFeatures::Feature::Value(1), ['way']);
add_feature('osmarender:nameDirection', new Geo::OSM::MapFeatures::Feature::Value(-1), ['way']);
add_feature('osmarender:render', new Geo::OSM::MapFeatures::Feature::Value('no'), ['node', 'way', 'area']);
add_feature('osmarender:renderName', new Geo::OSM::MapFeatures::Feature::Value('no'), ['node', 'way', 'area']);
add_feature('osmarender:renderRef', new Geo::OSM::MapFeatures::Feature::Value('no'), ['node', 'way', 'area']);

# add maplint keys
add_feature('validate:empty-tag-value', new Geo::OSM::MapFeatures::Feature::Value('ignore'), ['node', 'way', 'area']);
add_feature('validate:bridge-or-tunnel-without-layer', new Geo::OSM::MapFeatures::Feature::Value('ignore'), ['way']);
add_feature('validate:motorway-without-ref', new Geo::OSM::MapFeatures::Feature::Value('ignore'), ['way']);
add_feature('validate:place-of-worship-without-religion', new Geo::OSM::MapFeatures::Feature::Value('ignore'), ['node', 'way', 'area']);
add_feature('validate:poi-without-name', new Geo::OSM::MapFeatures::Feature::Value('ignore'), ['node', 'way', 'area']);
add_feature('validate:residential-without-name', new Geo::OSM::MapFeatures::Feature::Value('ignore'), ['way']);
add_feature('noname', new Geo::OSM::MapFeatures::Feature::Value('yes'), ['node', 'way', 'area']);

# add_feature( $key, $value, \@types )
# Pushes the feature onto the global list after
# checking for special things that have to be specially handled
# in the rule output section below
sub add_feature( $$$ ){
    my $key = shift;
    my $value = shift;
    my @types = @{ shift() };

    # name:''lg''
    if( $key =~ /(.*:)''lg''/i ){
	$key = "contains(\@k, '$1')";
    }

    # trick away the area type since the DB only has ways
    my %types = map { ("$_" eq 'area' ? 'way' : $_) => 1 } @types;
    @types = keys(%types);

    foreach my $type ( @types ){
	$type = lc($type);

	push(@{$main::keys{$type}{$key}}, $value);
    }
}

#
# OUTPUT
#

#use Data::Dumper; die Dumper(\%main::keys); #DEBUG

# Header
print <<EOF;
<?xml version='1.0' encoding='iso-8859-1' ?>
<!--
IMPORTANT NOTICE:

This is an AUTOGENERATED file.
Do NOT edit this file manually, edit not-in-map_features.pl instead
-->
<maplint:test group="strict" id="not-in-map_features" version="2" severity="notice"
    xmlns:maplint="http://maplint.openstreetmap.org/xml/1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

    <maplint:desc xml:lang="en">
      Checks tags against map features. These are not errors since everybody
      can invent new tags, but this helps find both misspelled tags as well as
      tags one may want to propose.
      This list is autogenerated from the wiki page.
    </maplint:desc>

EOF

# Type
foreach my $type ( keys(%main::keys) ){
    print "<maplint:check data='$type' type='application/xsl+xml'>\n";
    print "<xsl:for-each select=\"tag\">\n";
    print "<xsl:choose>\n";

    # Special handling of tiger:*
    print "<xsl:when test=\"starts-with(\@k, 'tiger:')\">\n";
    print "</xsl:when>\n";

    # Special handling of AND_*
    print "<xsl:when test=\"starts-with(\@k, 'AND_')\">\n";
    print "</xsl:when>\n";
    print "<xsl:when test=\"starts-with(\@k, 'AND:')\">\n";
    print "</xsl:when>\n";

    # Special handling of gns:*
    print "<xsl:when test=\"starts-with(\@k, 'gns:')\">\n";
    print "</xsl:when>\n";

    # Special handdling of massgis:*
    print "<xsl:when test=\"starts-with(\@k, 'massgis:')\">\n";
    print "</xsl:when>\n";

    # Special handling of openGeoDB/opengeodb:*
    print "<xsl:when test=\"starts-with(\@k, 'openGeoDB:')\">\n";
    print "</xsl:when>\n";
    print "<xsl:when test=\"starts-with(\@k, 'opengeodb:')\">\n";
    print "</xsl:when>\n";

    # Key
    foreach my $key ( sort( keys( %{$main::keys{$type}} ) ) ){
	# Key must either be a simple string or a valid XSL expression
	my $test;
	if( $key =~ /^[\w\d_\- :]+$/ ){
	    $test = "\@k='$key'";
	} else {
	    $test = $key;
	}
	print "<xsl:when test=\"$test\">\n";

	# Values
	my @values = sort( @{ $main::keys{$type}{$key} } );

        # Beware, horrible hack:
        # Skip the special value types we don't have format tests for by replacing them with userdef
        foreach my $value ( @values ){
            if( $value->isa('Geo::OSM::MapFeatures::Feature::Value::Date') ||
                $value->isa('Geo::OSM::MapFeatures::Feature::Value::Time') )
            {
                $value = new Geo::OSM::MapFeatures::Feature::Value('user defined');
            }
        }

        my $userdef = 1 if grep { $_->isa('Geo::OSM::MapFeatures::Feature::Value::Userdef') } @values;
	@values = grep { ! $_->isa('Geo::OSM::MapFeatures::Feature::Value::Userdef') } @values;

	# Is there a list of values, or is it only user defined
	if( @values ){
	    print "<xsl:choose>\n";
	    foreach my $value ( @values ){
                if( $value->isa('Geo::OSM::MapFeatures::Feature::Value::Num') ){
                    print "<xsl:when test=\"string(number(\@v)) != 'NaN'\" />\n";
                } elsif( $value->isa('Geo::OSM::MapFeatures::Feature::Value::Range') ){
                    print "<xsl:when test=\"\@v &gt; ".$value->from()." and \@v &lt; ".$value->to()."\" />\n";
                } elsif( $value->isa('Geo::OSM::MapFeatures::Feature::Value::List') ){
                    foreach my $item ( @{ $value->list() } ){
                        print "<xsl:when test=\"\@v='$item'\" />\n";
                    }
                } elsif( $value->isa('Geo::OSM::MapFeatures::Feature::Value::NumWithUnit') ){
                    # Number with optional unit suffixed
                    print "<xsl:when test='";
                    foreach my $unit ( @{ $value->units() } ){
                        print '(';
                        print 'contains(@v, "'.$unit.'") and '; # If we have a unit and ...
                        print 'string-length( substring-after(@v, "'.$unit.'") ) = 0 and '; # there's nothing behind said unit (important for the next part to work right)
                        print 'string(number('; # Number test
                        print 'substring(@v, 0, string-length(@v) - string-length("'.$unit.'"))'; # Get the part before the unit
                        print ')) != "NaN"'; # Number test part 2
                        print ') or ';
                    }
                    print '( string(number(@v)) != "NaN" )';
                    print "' />\n";
                } elsif( ref($value) eq 'Geo::OSM::MapFeatures::Feature::Value' ){
                    # Plain old normal value
		    print "<xsl:when test=\"\@v='$value'\" />\n";
                } else {
                    die "BUG: unknown value type: ".Dumper($value);use Data::Dumper;
                }
            }

	    # Can this value be user defined?
	    if( $userdef ){
		#print "<xsl:otherwise />\n";
		print "<!-- Uncomment to output notice about user defined value:\n";
		print "<xsl:otherwise>\n";
		print "<maplint:result><xsl:value-of select=\"concat('User defined value: ', \@k, '=', \@v)\" /></maplint:result>\n";
		print "</xsl:otherwise>\n";
		print " -->\n";
	    }
	    # If not everything but the above list is errors
	    else {
		print "<xsl:otherwise>\n";
		print "<maplint:result><xsl:value-of select=\"concat('Value not in map features: ', \@k, '=', \@v)\" /></maplint:result>\n";
		print "</xsl:otherwise>\n";
	    }
	    print "</xsl:choose>\n";
	}
	# Value can only be user defined:
	elsif( $userdef ){
	    print "<!-- Value: User defined -->\n";
	    #print "<maplint:result><xsl:value-of select=\"concat('User defined value: ', \@k, '=', \@v)\" /></maplint:result>\n";
	} else {
	    die "No possible values for key $key";
	}

	print "</xsl:when>\n";
    } # foreach key

    # Unknown key:
    print "<xsl:otherwise>\n";
    print "<maplint:result><xsl:value-of select=\"concat('Unknown key: ', \@k, '=', \@v)\" /></maplint:result>\n";
    print "</xsl:otherwise>\n";


    print "</xsl:choose>\n";
    print "</xsl:for-each>\n";
    print "</maplint:check>\n";
}
print "</maplint:test>\n";

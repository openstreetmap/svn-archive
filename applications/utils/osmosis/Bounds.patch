Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/bdb/v0_5/BdbWriter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/bdb/v0_5/BdbWriter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/bdb/v0_5/BdbWriter.java	(working copy)
@@ -8,6 +8,7 @@
 import com.bretth.osmosis.core.bdb.v0_5.impl.RelationDao;
 import com.bretth.osmosis.core.bdb.v0_5.impl.TransactionContext;
 import com.bretth.osmosis.core.bdb.v0_5.impl.WayDao;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
@@ -58,6 +59,13 @@
 	}
 	
 	
+	@Override
+    public void process(BoundsContainer bounds) {
+        // TODO Auto-generated method stub
+        // Just ignore it?
+    }
+
+
 	/**
 	 * {@inheritDoc}
 	 */
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/bdb/v0_5/BdbWriter.java.tmp
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/bdb/v0_5/BdbWriter.java.tmp	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/bdb/v0_5/BdbWriter.java.tmp	(revision 0)
@@ -0,0 +1,133 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.bdb.v0_5;
+
+import java.io.File;
+
+import com.bretth.osmosis.core.bdb.common.EnvironmentContext;
+import com.bretth.osmosis.core.bdb.v0_5.impl.NodeDao;
+import com.bretth.osmosis.core.bdb.v0_5.impl.RelationDao;
+import com.bretth.osmosis.core.bdb.v0_5.impl.TransactionContext;
+import com.bretth.osmosis.core.bdb.v0_5.impl.WayDao;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
+import com.bretth.osmosis.core.container.v0_5.EntityContainer;
+import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
+import com.bretth.osmosis.core.container.v0_5.NodeContainer;
+import com.bretth.osmosis.core.container.v0_5.RelationContainer;
+import com.bretth.osmosis.core.container.v0_5.WayContainer;
+import com.bretth.osmosis.core.task.v0_5.Sink;
+
+
+/**
+ * Receives input data as a stream and builds a java berkeley database
+ * containing all of the data.
+ * 
+ * @author Brett Henderson
+ */
+public class BdbWriter implements Sink, EntityProcessor {
+	private EnvironmentContext envCtx;
+	private TransactionContext txnCtx;
+	private NodeDao nodeDao;
+	private WayDao wayDao;
+	private RelationDao relationDao;
+	
+	private boolean initialized;
+	
+	
+	/**
+	 * Creates a new instance.
+	 * 
+	 * @param home
+	 *            The directory to store all data files in.
+	 */
+	public BdbWriter(File home) {
+		envCtx = new EnvironmentContext(home, true, false);
+		
+		initialized = false;
+	}
+	
+	
+	/**
+	 * Opens all database resources for use.
+	 */
+	private void initialize() {
+		txnCtx = new TransactionContext(envCtx);
+		nodeDao = txnCtx.getNodeDao();
+		wayDao = txnCtx.getWayDao();
+		relationDao = txnCtx.getRelationDao();
+		
+		initialized = true;
+	}
+	
+	
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void process(EntityContainer entityContainer) {
+		if (!initialized) {
+			initialize();
+		}
+		entityContainer.process(this);
+	}
+	
+	
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void process(NodeContainer nodeContainer) {
+		nodeDao.putNode(nodeContainer.getEntity());
+	}
+	
+	
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void process(WayContainer wayContainer) {
+		wayDao.putWay(wayContainer.getEntity());
+	}
+	
+	
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void process(RelationContainer relationContainer) {
+		relationDao.putRelation(relationContainer.getEntity());
+	}
+	
+	
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void complete() {
+		if (!initialized) {
+			initialize();
+		}
+		
+		txnCtx.complete();
+		envCtx.complete();
+	}
+	
+	
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void release() {
+		txnCtx.release();
+		envCtx.release();
+	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+    public void process(BoundsContainer bounds) {
+	    // TODO Auto-generated method stub
+		// Just ignore it?
+    }
+}
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/change/v0_5/impl/TimestampChangeSetter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/change/v0_5/impl/TimestampChangeSetter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/change/v0_5/impl/TimestampChangeSetter.java	(working copy)
@@ -6,6 +6,7 @@
 
 import com.bretth.osmosis.core.container.v0_5.ChangeContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
 import com.bretth.osmosis.core.container.v0_5.RelationContainer;
 import com.bretth.osmosis.core.container.v0_5.WayContainer;
@@ -109,4 +110,12 @@
 			)
 		);
 	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	public void process(BoundsContainer boundsContainer) {
+		changeSink.process(new ChangeContainer(boundsContainer, action));
+	}
 }
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/container/v0_5/BoundsContainer.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/container/v0_5/BoundsContainer.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/container/v0_5/BoundsContainer.java	(revision 0)
@@ -0,0 +1,70 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.container.v0_5;
+
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
+import com.bretth.osmosis.core.domain.v0_5.Node;
+import com.bretth.osmosis.core.store.StoreClassRegister;
+import com.bretth.osmosis.core.store.StoreReader;
+import com.bretth.osmosis.core.store.StoreWriter;
+
+/**
+ * Entity container implementation for bounds.
+ * 
+ * @author knewman
+ */
+public class BoundsContainer extends EntityContainer {
+
+	private Bounds bounds;
+
+
+	/**
+	 * Creates a new instance.
+	 * 
+	 * @param bounds
+	 *            The bounds to wrap.
+	 */
+	public BoundsContainer(Bounds bounds) {
+		this.bounds = bounds;
+	}
+
+
+	/**
+	 * Creates a new instance.
+	 * 
+	 * @param sr
+	 *            The store to read state from.
+	 * @param scr
+	 *            Maintains the mapping between classes and their identifiers
+	 *            within the store.
+	 */
+	public BoundsContainer(StoreReader sr, StoreClassRegister scr) {
+		bounds = new Bounds(sr, scr);
+	}
+	
+	
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public Bounds getEntity() {
+		return bounds;
+	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void store(StoreWriter sw, StoreClassRegister scr) {
+		bounds.store(sw, scr);
+	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void process(EntityProcessor processor) {
+		processor.process(this);
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\src\com\bretth\osmosis\core\container\v0_5\BoundsContainer.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/container/v0_5/EntityProcessor.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/container/v0_5/EntityProcessor.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/container/v0_5/EntityProcessor.java	(working copy)
@@ -11,6 +11,14 @@
 public interface EntityProcessor {
 	
 	/**
+	 * Process the bounds.
+	 * 
+	 * @param bounds
+	 *            The bounds to be processed.
+	 */
+	public void process(BoundsContainer bounds);
+	
+	/**
 	 * Process the node.
 	 * 
 	 * @param node
@@ -17,7 +25,7 @@
 	 *            The node to be processed.
 	 */
 	public void process(NodeContainer node);
-	
+
 	/**
 	 * Process the way.
 	 * 
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/customdb/v0_5/impl/DatasetStore.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/customdb/v0_5/impl/DatasetStore.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/customdb/v0_5/impl/DatasetStore.java	(working copy)
@@ -5,6 +5,7 @@
 import java.util.logging.Logger;
 
 import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.Dataset;
 import com.bretth.osmosis.core.container.v0_5.DatasetReader;
 import com.bretth.osmosis.core.container.v0_5.EntityContainer;
@@ -111,9 +112,9 @@
 		);
 		nodeObjectOffsetIndexWriter = storeContainer.add(
 			new IndexStore<Long, LongLongIndexElement>(
-				LongLongIndexElement.class,
-				new ComparableComparator<Long>(),
-				fileManager.getNodeObjectOffsetIndexFile()
+			LongLongIndexElement.class,
+			new ComparableComparator<Long>(),
+			fileManager.getNodeObjectOffsetIndexFile()
 			)
 		);
 		nodeTileIndexWriter = storeContainer.add(
@@ -118,9 +119,9 @@
 		);
 		nodeTileIndexWriter = storeContainer.add(
 			new IndexStore<Integer, IntegerLongIndexElement>(
-				IntegerLongIndexElement.class,
-				uintComparator,
-				fileManager.getNodeTileIndexFile()
+			IntegerLongIndexElement.class,
+			uintComparator,
+			fileManager.getNodeTileIndexFile()
 			)
 		);
 		
@@ -205,6 +206,12 @@
 	}
 	
 	
+	@Override
+    public void process(BoundsContainer bounds) {
+        // TODO Do nothing?
+    }
+
+
 	/**
 	 * {@inheritDoc}
 	 */
@@ -262,54 +269,54 @@
 		);
 		
 		if (enableWayTileIndex) {
-			// Calculate the minimum and maximum tile indexes for the way.
-			tilesFound = false;
-			minimumTile = 0;
-			maximumTile = 0;
-			for (WayNode wayNode : way.getWayNodeList()) {
-				long nodeId;
-				Node node;
-				int tile;
+		// Calculate the minimum and maximum tile indexes for the way.
+		tilesFound = false;
+		minimumTile = 0;
+		maximumTile = 0;
+		for (WayNode wayNode : way.getWayNodeList()) {
+			long nodeId;
+			Node node;
+			int tile;
+			
+			nodeId = wayNode.getNodeId();
+			
+			try {
+			node = nodeObjectReader.get(
+				nodeObjectOffsetIndexReader.get(nodeId).getValue()
+			);
+			
+			tile = (int) tileCalculator.calculateTile(node.getLatitude(), node.getLongitude());
+			
+			if (tilesFound) {
+				if (uintComparator.compare(tile, minimumTile) < 0) {
+					minimumTile = tile;
+				}
+				if (uintComparator.compare(maximumTile, tile) < 0) {
+					maximumTile = tile;
+				}
+				
+			} else {
+				minimumTile = tile;
+				maximumTile = tile;
 				
-				nodeId = wayNode.getNodeId();
+				tilesFound = true;
+			}
 				
-				try {
-					node = nodeObjectReader.get(
-						nodeObjectOffsetIndexReader.get(nodeId).getValue()
+			} catch (NoSuchIndexElementException e) {
+				// Ignore any referential integrity problems.
+				if (log.isLoggable(Level.FINER)) {
+					log.finest(
+						"Ignoring referential integrity problem where way " + wayId +
+						" refers to non-existent node " + nodeId + "."
 					);
-					
-					tile = (int) tileCalculator.calculateTile(node.getLatitude(), node.getLongitude());
-					
-					if (tilesFound) {
-						if (uintComparator.compare(tile, minimumTile) < 0) {
-							minimumTile = tile;
-						}
-						if (uintComparator.compare(maximumTile, tile) < 0) {
-							maximumTile = tile;
-						}
-						
-					} else {
-						minimumTile = tile;
-						maximumTile = tile;
-						
-						tilesFound = true;
-					}
-					
-				} catch (NoSuchIndexElementException e) {
-					// Ignore any referential integrity problems.
-					if (log.isLoggable(Level.FINER)) {
-						log.finest(
-							"Ignoring referential integrity problem where way " + wayId +
-							" refers to non-existent node " + nodeId + "."
-						);
-					}
-				}
+		}
 			}
-			
-			// Write the way id to an index keyed by tile but only if tiles were
-			// actually found.
-			if (tilesFound) {
-				wayTileIndexWriter.write(wayId, minimumTile, maximumTile);
+		}
+		
+		// Write the way id to an index keyed by tile but only if tiles were
+		// actually found.
+		if (tilesFound) {
+		wayTileIndexWriter.write(wayId, minimumTile, maximumTile);
 			}
 			
 		} else {
@@ -320,7 +327,7 @@
 				
 				nodeWayIndexWriter.write(new LongLongIndexElement(nodeId, wayId));
 			}
-		}
+	}
 	}
 	
 	
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/domain/v0_5/Bounds.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/domain/v0_5/Bounds.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/domain/v0_5/Bounds.java	(revision 0)
@@ -0,0 +1,456 @@
+package com.bretth.osmosis.core.domain.v0_5;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedList;
+
+import com.bretth.osmosis.core.store.StoreClassRegister;
+import com.bretth.osmosis.core.store.StoreReader;
+import com.bretth.osmosis.core.store.StoreWriter;
+
+/**
+ * A data class representing an OSM data bounds element.
+ * 
+ * @author Karl Newman
+ */
+public class Bounds extends Entity implements Comparable<Bounds> {
+
+	private static final double MIN_LATITUDE = -90.0;
+	private static final double MAX_LATITUDE = 90.0;
+	private static final double MIN_LONGITUDE = -180.0;
+	private static final double MAX_LONGITUDE = 180.0;
+
+	private double right;
+	private double left;
+	private double top;
+	private double bottom;
+	private String origin;
+
+
+	/**
+	 * Creates a new instance which covers the entire planet.
+	 * 
+	 * @param origin
+	 *            The origin (source) of the data, typically a URI
+	 * 
+	 */
+	public Bounds(String origin) {
+		this(MAX_LONGITUDE, MIN_LONGITUDE, MAX_LATITUDE, MIN_LATITUDE, origin);
+	}
+
+
+	/**
+	 * Creates a new instance with the specified boundaries.
+	 * 
+	 * @param right
+	 *            The longitude coordinate of the right (East) edge of the bounds
+	 * @param left
+	 *            The longitude coordinate of the left (West) edge of the bounds
+	 * @param top
+	 *            The latitude coordinate of the top (North) edge of the bounds
+	 * @param bottom
+	 *            The latitude coordinate of the bottom (South) edge of the bounds
+	 * @param origin
+	 *            The origin (source) of the data, typically a URI
+	 */
+	public Bounds(double right, double left, double top, double bottom, String origin) {
+		super(0, new Date(), ""); // minimal underlying entity
+		// Check if any coordinates are out of bounds
+		if (Double.compare(right, MAX_LONGITUDE) > 0
+		        || Double.compare(right, MIN_LONGITUDE) < 0
+		        || Double.compare(left, MAX_LONGITUDE) > 0
+		        || Double.compare(left, MIN_LONGITUDE) < 0
+		        || Double.compare(top, MAX_LATITUDE) > 0
+		        || Double.compare(top, MIN_LATITUDE) < 0
+		        || Double.compare(bottom, MAX_LATITUDE) > 0
+		        || Double.compare(bottom, MIN_LATITUDE) < 0) {
+			throw new IllegalArgumentException("Bounds coordinates outside of valid range");
+		}
+		if (Double.compare(top, bottom) < 0) {
+			throw new IllegalArgumentException("Bounds top < bottom");
+		}
+		if (origin == null) {
+			throw new IllegalArgumentException("Bounds origin is null");
+		}
+		this.right = right;
+		this.left = left;
+		this.top = top;
+		this.bottom = bottom;
+		this.origin = origin;
+	}
+
+
+	/**
+	 * Creates a new instance.
+	 * 
+	 * @param sr
+	 *            The store to read state from.
+	 * @param scr
+	 *            Maintains the mapping between classes and their identifiers within the store.
+	 */
+	public Bounds(StoreReader sr, StoreClassRegister scr) {
+		super(sr, scr);
+
+		this.right = sr.readDouble();
+		this.left = sr.readDouble();
+		this.top = sr.readDouble();
+		this.bottom = sr.readDouble();
+		this.origin = sr.readString();
+	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void store(StoreWriter sw, StoreClassRegister scr) {
+		super.store(sw, scr);
+
+		sw.writeDouble(right);
+		sw.writeDouble(left);
+		sw.writeDouble(top);
+		sw.writeDouble(bottom);
+		sw.writeString(origin);
+	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public EntityType getType() {
+		return EntityType.Bounds;
+	}
+
+
+	/**
+	 * @return The right (East) bounds longitude
+	 */
+	public double getRight() {
+		return right;
+	}
+
+
+	/**
+	 * @return The left (West) bounds longitude
+	 */
+	public double getLeft() {
+		return left;
+	}
+
+
+	/**
+	 * @return The top (North) bounds latitude
+	 */
+	public double getTop() {
+		return top;
+	}
+
+
+	/**
+	 * @return The bottom (South) bounds latitude
+	 */
+	public double getBottom() {
+		return bottom;
+	}
+
+
+	/**
+	 * @return the origin
+	 */
+	public String getOrigin() {
+		return origin;
+	}
+
+
+	/**
+	 * Calculate the intersected area of this with the specified bounds
+	 * 
+	 * @param intersectingBounds
+	 *            Bounds element with which to calculate the intersection
+	 * @return Bounds Resultant intersection of the two bounds
+	 */
+	public Bounds intersect(Bounds intersectingBounds) {
+		double newRight = 0.0, newLeft = 0.0, newTop, newBottom;
+
+		boolean intersect180, this180; // flags to indicate bounds cross antimeridian
+
+		if (intersectingBounds == null) {
+			return null; // no intersection
+		}
+		// first check the vertical intersection
+		newTop = Math.min(this.getTop(), intersectingBounds.getTop());
+		newBottom = Math.max(this.getBottom(), intersectingBounds.getBottom());
+		if (Double.compare(newBottom, newTop) >= 0) { // no north-south intersecting region
+			return null;
+		}
+
+		intersect180 = (Double.compare(intersectingBounds.getLeft(), intersectingBounds.getRight()) > 0);
+		this180 = (Double.compare(this.getLeft(), this.getRight()) > 0);
+
+		if ((intersect180 && this180) || !(intersect180 || this180)) {
+			// if both or neither cross the antimeridian, use the simple case
+			newRight = Math.min(this.getRight(), intersectingBounds.getRight());
+			newLeft = Math.max(this.getLeft(), intersectingBounds.getLeft());
+			if (!(intersect180 || this180) && (Double.compare(newLeft, newRight) >= 0)) {
+				/*
+				 * This is only applicable for the case where neither cross the antimeridian,
+				 * because if both cross, they must intersect.
+				 */
+				return null; // no intersecting area
+			}
+		} else {
+			Bounds b1, b2; // stand-ins for this and intersectingBounds
+
+			if (intersect180 && !this180) {
+				// passed parameter Bounds crosses the antimeridian, this Bounds doesn't
+				b1 = this;
+				b2 = intersectingBounds;
+			} else {
+				// this Bounds crosses the antimeridian, passed parameter Bounds doesn't
+				b1 = intersectingBounds;
+				b2 = this;
+			}
+			if (Double.compare(b1.getRight(), b2.getLeft()) > 0
+			        && Double.compare(b1.getLeft(), b2.getRight()) < 0) {
+				// intersects on both sides of the antimeridian--just pick the smaller of the
+				// two
+				Double diff1 = b1.getRight() - b1.getLeft();
+				Double diff2 = b2.getRight() - MIN_LONGITUDE + MAX_LONGITUDE - b2.getLeft();
+				if (Double.compare(diff1, diff2) <= 0) {
+					newRight = b1.getRight();
+					newLeft = b1.getLeft();
+				} else {
+					newRight = b2.getRight();
+					newLeft = b2.getLeft();
+				}
+			} else if (Double.compare(b1.getRight(), b2.getLeft()) > 0) {
+				// intersects on the East side of the antimeridian
+				newRight = b1.getRight();
+				newLeft = b2.getLeft();
+			} else if (Double.compare(b1.getLeft(), b2.getRight()) < 0) {
+				// intersects on the West side of the antimeridian
+				newRight = b2.getRight();
+				newLeft = b1.getLeft();
+			}
+		}
+		if (Double.compare(newRight, newLeft) == 0) {
+			return null;
+		}
+		// Keep the origin string from this if it's not blank, otherwise use the origin string from
+		// the intersecting Bounds
+		return new Bounds(newRight, newLeft, newTop, newBottom, this.getOrigin() != ""
+		        ? this.getOrigin()
+		        : intersectingBounds.getOrigin());
+	}
+
+
+	/**
+	 * Calculate the union area of this with the specified bounds. Not a strict mathematical union,
+	 * but the smallest rectangular area which includes both bounds. Thus, result may include areas
+	 * not contained in the original bounds.
+	 * 
+	 * @param unionBounds
+	 *            Bounds element with which to calculate the union
+	 * @return Bounds Resultant union of the two bounds
+	 */
+	public Bounds union(Bounds unionBounds) {
+		double newRight = 0.0, newLeft = 0.0, newTop, newBottom;
+
+		if (unionBounds == null) {
+			return this; // nothing to compute a union with
+		}
+
+		// First compute the vertical union
+		newTop = Math.max(this.getTop(), unionBounds.getTop());
+		newBottom = Math.min(this.getBottom(), unionBounds.getBottom());
+		if (Double.compare(newBottom, newTop) >= 0) { // no north-south intersecting region
+			return null;
+		}
+		// Next check the (likely) common case where one of the bounds covers the planet
+		if ((Double.compare(this.getLeft(), MIN_LONGITUDE) == 0 && Double.compare(
+		        this.getRight(),
+		        MAX_LONGITUDE) == 0)
+		        || (Double.compare(unionBounds.getLeft(), MIN_LONGITUDE) == 0 && Double.compare(
+		                unionBounds.getRight(),
+		                MAX_LONGITUDE) == 0)) {
+			newRight = MAX_LONGITUDE;
+			newLeft = MIN_LONGITUDE;
+		} else {
+			boolean union180, this180; // flags to indicate bounds cross antimeridian
+			double size1, size2; // resulting union sizes for comparison
+
+			union180 = (Double.compare(unionBounds.getLeft(), unionBounds.getRight()) > 0);
+			this180 = (Double.compare(this.getLeft(), this.getRight()) > 0);
+
+			if (union180 && this180) {
+				// if both cross the antimeridian, then the union will cross, too.
+				newRight = Math.max(this.getRight(), unionBounds.getRight());
+				newLeft = Math.min(this.getLeft(), unionBounds.getLeft());
+			} else if (!(union180 || this180)) {
+				// neither cross the antimeridian, but the union might
+
+				// first calculate the size of a simple union which doesn't cross the antimeridian
+				size1 = Math.max(this.getRight(), unionBounds.getRight())
+				        - Math.min(this.getLeft(), unionBounds.getLeft());
+				// then calculate the size of the resulting union which does cross the antimeridian
+				size2 = (Math.min(this.getRight(), unionBounds.getRight()) - MIN_LONGITUDE)
+				        + (MAX_LONGITUDE - Math.max(this.getLeft(), unionBounds.getLeft()));
+
+				// now pick the smaller of the two
+				if (Double.compare(size1, size2) <= 0) {
+					newRight = Math.max(this.getRight(), unionBounds.getRight());
+					newLeft = Math.min(this.getLeft(), unionBounds.getLeft());
+				} else {
+					newRight = Math.min(this.getRight(), unionBounds.getRight());
+					newLeft = Math.max(this.getLeft(), unionBounds.getLeft());
+				}
+			} else {
+				// One of the Bounds crosses the antimeridian, the other doesn't
+				Bounds b1, b2;
+				if (union180 && !this180) {
+					// passed parameter Bounds crosses the antimeridian, this Bounds doesn't
+					b1 = unionBounds;
+					b2 = this;
+				} else {
+					// this Bounds crosses the antimeridian, passed parameter Bounds doesn't
+					b1 = this;
+					b2 = unionBounds;
+				}
+
+				// check for the case where the two Bounds overlap on both edges such that the union
+				// covers the planet.
+				if (Double.compare(b1.getRight(), b2.getLeft()) >= 0
+				        && Double.compare(b1.getLeft(), b2.getRight()) <= 0) {
+					newLeft = MIN_LONGITUDE;
+					newRight = MAX_LONGITUDE;
+				} else {
+					// first calculate the size of a union with the simple bounds added to the left
+					size1 = (Math.max(b1.getRight(), b2.getRight()) - MIN_LONGITUDE)
+					        + (MAX_LONGITUDE - b1.getLeft());
+					// first calculate the size of a union with the simple bounds added to the right
+					size2 = (b1.getRight() - MIN_LONGITUDE)
+					        + (MAX_LONGITUDE - Math.min(b1.getLeft(), b2.getLeft()));
+
+					// now pick the smaller of the two
+					if (Double.compare(size1, size2) <= 0) {
+						newRight = Math.max(b1.getRight(), b2.getRight());
+						newLeft = b1.getLeft();
+					} else {
+						newRight = b1.getRight();
+						newLeft = Math.min(b1.getLeft(), b2.getLeft());
+					}
+				}
+			}
+		}
+
+		if (Double.compare(newRight, newLeft) == 0) {
+			return null;
+		}
+		// Keep the origin string from this if it's not blank, otherwise use the origin string from
+		// the union Bounds
+		return new Bounds(newRight, newLeft, newTop, newBottom, this.getOrigin() != ""
+		        ? this.getOrigin()
+		        : unionBounds.getOrigin());
+	}
+
+
+	/**
+	 * Retrieve a collection of Bounds objects which collectively comprise the entirety of this
+	 * Bounds but individually do not cross the antimeridian and thus can be used in simple area
+	 * operations. The degenerate case will return this Bounds.
+	 * 
+	 * @return Iterable collection of Bounds elements
+	 */
+	public Iterable<Bounds> toSimpleBounds() {
+		Collection<Bounds> c = new LinkedList<Bounds>();
+		if (Double.compare(this.getLeft(), this.getRight()) < 0) {
+			// simple case, just return this
+			c.add(this);
+		} else {
+			// split the bounds into two parts--one on either side of the antimeridian
+			c.add(new Bounds(
+			        MAX_LONGITUDE,
+			        this.getLeft(),
+			        this.getTop(),
+			        this.getBottom(),
+			        this.getOrigin()));
+			c.add(new Bounds(
+			        this.getRight(),
+			        MIN_LONGITUDE,
+			        this.getTop(),
+			        this.getBottom(),
+			        this.getOrigin()));
+		}
+		return Collections.unmodifiableCollection(c);
+	}
+
+
+	/**
+	 * Compares this bounds to the specified bounds. The bounds comparison is based on a comparison
+	 * of area, latitude, and longitude in that order.
+	 * 
+	 * @param comparisonBounds
+	 *            The bounds to compare to.
+	 * @return 0 if equal, <0 if this sorts before comparison (this is "smaller"), and >0 if this
+	 *         sorts before comparison (this is "bigger")
+	 */
+	public int compareTo(Bounds comparisonBounds) {
+		double areaT = 0.0, areaC = 0.0;
+		int result;
+
+		/*
+		 * This is a very simple "area" calculation just using the coordinate values, not accounting
+		 * for any projections.
+		 */
+		for (Bounds b : this.toSimpleBounds()) {
+			areaT += (b.getRight() - b.getLeft()) * (b.getTop() - b.getBottom());
+		}
+		for (Bounds b : comparisonBounds.toSimpleBounds()) {
+			areaC += (b.getRight() - b.getLeft()) * (b.getTop() - b.getBottom());
+		}
+
+		// Use Double.compare (instead of < and >) to catch unique border cases
+		result = Double.compare(areaT, areaC);
+		if (result != 0) {
+			return result;
+		}
+
+		result = Double.compare(this.getTop(), comparisonBounds.getTop());
+		if (result != 0) {
+			return result;
+		}
+
+		result = Double.compare(this.getBottom(), comparisonBounds.getBottom());
+		if (result != 0) {
+			return result;
+		}
+
+		result = Double.compare(this.getLeft(), comparisonBounds.getLeft());
+		if (result != 0) {
+			return result;
+		}
+
+		result = Double.compare(this.getRight(), comparisonBounds.getRight());
+		if (result != 0) {
+			return result;
+		}
+
+		result = this.getOrigin().compareTo(comparisonBounds.getOrigin());
+		return result;
+	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public boolean equals(Object o) {
+		if (o instanceof Bounds) {
+			return compareTo((Bounds)o) == 0;
+		} else {
+			return false;
+		}
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\src\com\bretth\osmosis\core\domain\v0_5\Bounds.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/domain/v0_5/EntityType.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/domain/v0_5/EntityType.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/domain/v0_5/EntityType.java	(working copy)
@@ -9,6 +9,11 @@
  */
 public enum EntityType {
 	/**
+	 * Singleton representation of the latitude/longitude bounding box of the entity stream.
+	 */
+	Bounds,
+
+	/**
 	 * Represents a geographical point.
 	 */
 	Node,
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/filter/v0_5/AreaFilter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/filter/v0_5/AreaFilter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/filter/v0_5/AreaFilter.java	(working copy)
@@ -2,6 +2,7 @@
 package com.bretth.osmosis.core.filter.v0_5;
 
 import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
@@ -12,7 +13,6 @@
 import com.bretth.osmosis.core.domain.v0_5.RelationMember;
 import com.bretth.osmosis.core.domain.v0_5.WayNode;
 import com.bretth.osmosis.core.domain.v0_5.Relation;
-import com.bretth.osmosis.core.domain.v0_5.Tag;
 import com.bretth.osmosis.core.domain.v0_5.Way;
 import com.bretth.osmosis.core.filter.common.IdTracker;
 import com.bretth.osmosis.core.filter.common.IdTrackerFactory;
@@ -84,6 +84,14 @@
 	
 	
 	/**
+	 * {@inheritDoc}
+	 */
+	public void process(BoundsContainer boundsContainer) {
+		// By default, pass it on unchanged
+		sink.process(boundsContainer);
+	}
+
+	/**
 	 * Indicates if the node lies within the area required.
 	 * 
 	 * @param node
@@ -174,9 +182,7 @@
 		// Only add ways that contain nodes.
 		if (filteredWay.getWayNodeList().size() > 0) {
 			// Add all tags to the filtered way.
-			for (Tag tag : way.getTagList()) {
-				filteredWay.addTag(tag);
-			}
+			filteredWay.addTags(way.getTagList());
 			
 			sink.process(new WayContainer(filteredWay));
 		}
@@ -267,9 +273,7 @@
 		// Only add relations that contain entities.
 		if (filteredRelation.getMemberList().size() > 0) {
 			// Add all tags to the filtered relation.
-			for (Tag tag : relation.getTagList()) {
-				filteredRelation.addTag(tag);
-			}
+			filteredRelation.addTags(relation.getTagList());
 			
 			sink.process(new RelationContainer(filteredRelation));
 		}
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/filter/v0_5/BoundingBoxFilter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/filter/v0_5/BoundingBoxFilter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/filter/v0_5/BoundingBoxFilter.java	(working copy)
@@ -1,13 +1,14 @@
 // License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
 package com.bretth.osmosis.core.filter.v0_5;
 
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
 import com.bretth.osmosis.core.domain.v0_5.Node;
 import com.bretth.osmosis.core.filter.common.IdTrackerType;
 
-
 /**
- * Provides a filter for extracting all entities that lie within a specific
- * geographical box identified by latitude and longitude coordinates.
+ * Provides a filter for extracting all entities that lie within a specific geographical box
+ * identified by latitude and longitude coordinates.
  * 
  * @author Brett Henderson
  */
@@ -12,15 +13,12 @@
  * @author Brett Henderson
  */
 public class BoundingBoxFilter extends AreaFilter {
-	private double left;
-	private double right;
-	private double top;
-	private double bottom;
-	
-	
+	private Bounds bounds; // use a Bounds for the internal representation
+
+
 	/**
-	 * Creates a new instance with the specified geographical coordinates. When
-	 * filtering, nodes right on the edge of the box will be included.
+	 * Creates a new instance with the specified geographical coordinates. When filtering, nodes
+	 * right on the edge of the box will be included.
 	 * 
 	 * @param idTrackerType
 	 *            Defines the id tracker implementation to use.
@@ -35,18 +33,41 @@
 	 * @param completeWays
 	 *            Include all nodes for ways which have at least one node inside the filtered area.
 	 * @param completeRelations
-	 *            Include all relations referenced by other relations which have members inside
-	 *            the filtered area.
+	 *            Include all relations referenced by other relations which have members inside the
+	 *            filtered area.
+	 */
+	public BoundingBoxFilter(IdTrackerType idTrackerType,
+	        double left,
+	        double right,
+	        double top,
+	        double bottom,
+	        boolean completeWays,
+	        boolean completeRelations) {
+		super(idTrackerType, completeWays, completeRelations);
+		this.bounds = new Bounds(right, left, top, bottom, "");
+	}
+
+
+	/**
+	 * {@inheritDoc}
 	 */
-	public BoundingBoxFilter(IdTrackerType idTrackerType, double left, double right, double top, double bottom, boolean completeWays, boolean completeRelations) {
-	    	super(idTrackerType, completeWays, completeRelations);
-		this.left = left;
-		this.right = right;
-		this.top = top;
-		this.bottom = bottom;
+	@Override
+	public void process(BoundsContainer boundsContainer) {
+		Bounds newBounds;
+		/*
+		 * The order of calling intersect is important because the first non-empty origin string
+		 * will be used for the resulting Bounds, and we want the origin string from the pipeline
+		 * Bounds to be used.
+		 */
+		newBounds = boundsContainer.getEntity().intersect(bounds);
+		// intersect will return null if there is no overlapping area
+		if (newBounds != null) {
+			// Send on a bounds element clipped to the area
+			super.process(new BoundsContainer(newBounds));
+		}
 	}
-	
-	
+
+
 	/**
 	 * {@inheritDoc}
 	 */
@@ -54,10 +75,22 @@
 	protected boolean isNodeWithinArea(Node node) {
 		double latitude;
 		double longitude;
-		
+
 		latitude = node.getLatitude();
 		longitude = node.getLongitude();
-		
-		return top >= latitude && bottom <= latitude && left <= longitude && right >= longitude;
+
+		/*
+		 * Check the node coordinates against the bounding box by comparing them to each "simple"
+		 * bounds.
+		 */
+		for (Bounds b : bounds.toSimpleBounds()) {
+			if (b.getTop() >= latitude
+			        && b.getBottom() <= latitude
+			        && b.getLeft() <= longitude
+			        && b.getRight() >= longitude) {
+				return true;
+			}
+		}
+		return false;
 	}
 }
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/filter/v0_5/PolygonFilter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/filter/v0_5/PolygonFilter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/filter/v0_5/PolygonFilter.java	(working copy)
@@ -2,8 +2,11 @@
 package com.bretth.osmosis.core.filter.v0_5;
 
 import java.awt.geom.Area;
+import java.awt.geom.Rectangle2D;
 import java.io.File;
 
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
 import com.bretth.osmosis.core.domain.v0_5.Node;
 import com.bretth.osmosis.core.filter.common.IdTrackerType;
 import com.bretth.osmosis.core.filter.common.PolygonFileReader;
@@ -46,6 +49,78 @@
 	 * {@inheritDoc}
 	 */
 	@Override
+	public void process(BoundsContainer boundsContainer) {
+		Bounds newBounds = null;
+
+		// Configure the area if it hasn't been created yet. (Should this be in an "initialize" method?)
+		if (area == null) {
+			area = new PolygonFileReader(polygonFile).loadPolygon();
+		}
+		
+		for (Bounds b : boundsContainer.getEntity().toSimpleBounds()) {
+			if (newBounds == null) {
+				newBounds = simpleBoundsIntersect(b);
+			} else {
+				newBounds = newBounds.union(simpleBoundsIntersect(b));
+			}
+		}
+
+		if (newBounds != null) {
+			super.process(new BoundsContainer(newBounds));
+		}
+	}
+
+
+	/**
+	 * Get the simple intersection of this polygon with the passed Bounds.
+	 * 
+	 * @param bounds
+	 *            Bounds with which to intersect. Must be "simple" (not cross antimeridian).
+	 * @return Bounds resulting rectangular area after intersection
+	 */
+	private Bounds simpleBoundsIntersect(Bounds bounds) {
+		Rectangle2D r;
+		double width, height;
+
+		Bounds newBounds = null;
+		Area a2 = (Area)area.clone(); // make a copy so we don't disturb the original
+
+		/*
+		 * Note that AWT uses the computer graphics convention with the origin at the top left, so
+		 * top and bottom are reversed for a Rectangle2D vs. a Bounds.
+		 */
+
+		if (bounds.getLeft() > bounds.getRight()) {
+			return null;
+		}
+		width = bounds.getRight() - bounds.getLeft();
+		height = bounds.getTop() - bounds.getBottom();
+		/*
+		 * Perform the intersect against the Area itself instead of its bounding box for maximum
+		 * precision.
+		 */
+		a2.intersect(new Area(new Rectangle2D.Double(
+		        bounds.getLeft(),
+		        bounds.getBottom(),
+		        width,
+		        height)));
+		if (!a2.isEmpty()) {
+			r = a2.getBounds2D();
+			newBounds = new Bounds(
+			        r.getMaxX(),
+			        r.getMinX(),
+			        r.getMaxY(),
+			        r.getMinY(),
+			        bounds.getOrigin());
+		}
+		return newBounds;
+	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
 	protected boolean isNodeWithinArea(Node node) {
 		double latitude;
 		double longitude;
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/impl/ActionChangeWriter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/impl/ActionChangeWriter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/impl/ActionChangeWriter.java	(working copy)
@@ -1,6 +1,7 @@
 // License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
 package com.bretth.osmosis.core.mysql.v0_5.impl;
 
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
 import com.bretth.osmosis.core.container.v0_5.RelationContainer;
@@ -33,6 +34,14 @@
 	
 	
 	/**
+     * {@inheritDoc}
+     */
+    public void process(BoundsContainer bounds) {
+        // Ignore it
+    }
+
+
+	/**
 	 * {@inheritDoc}
 	 */
 	public void process(NodeContainer nodeContainer) {
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/MySqlCurrentReader.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/MySqlCurrentReader.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/MySqlCurrentReader.java	(working copy)
@@ -122,6 +122,8 @@
 			if (preferences.getValidateSchemaVersion()) {
 				new SchemaVersionValidator(loginCredentials).validateVersion(MySqlVersionConstants.SCHEMA_VERSION);
 			}
+			// TODO: Create a Bounds element here and send it down the pipeline.
+			// Need to figure out what to do about the origin string, though.
 			processNodes();
 			processWays();
 			processRelations();
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/MysqlReader.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/MysqlReader.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/MysqlReader.java	(working copy)
@@ -150,6 +150,8 @@
 			if (preferences.getValidateSchemaVersion()) {
 				new SchemaVersionValidator(loginCredentials).validateVersion(MySqlVersionConstants.SCHEMA_VERSION);
 			}
+			// TODO: Create a Bounds element here and send it down the pipeline.
+			// Need to figure out what to do about the origin string, though.
 			processNodes();
 			processWays();
 			processRelations();
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/MysqlWriter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/MysqlWriter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/mysql/v0_5/MysqlWriter.java	(working copy)
@@ -8,6 +8,7 @@
 import java.util.List;
 
 import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
@@ -1151,4 +1152,11 @@
 		
 		flushRelationMembers(false);
 	}
+	
+	/**
+	 * {@inheritDoc}
+	 */
+	public void process(BoundsContainer boundsContainer) {
+		// Ignore it
+	}
 }
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/pgsql/common/v0_5/PostgreSqlDumpWriter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/pgsql/common/v0_5/PostgreSqlDumpWriter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/pgsql/common/v0_5/PostgreSqlDumpWriter.java	(working copy)
@@ -4,6 +4,7 @@
 import java.io.File;
 import java.util.Map.Entry;
 
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
@@ -82,6 +83,13 @@
 		// Do nothing.
 	}
 	
+	/**
+	 * {@inheritDoc}
+	 */
+	public void process(BoundsContainer boundsContainer) {
+		// Ignore it
+	}
+	
 	
 	/**
 	 * Writes any buffered data to the database and commits. 
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/pgsql/common/v0_5/PostgreSqlWriter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/pgsql/common/v0_5/PostgreSqlWriter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/pgsql/common/v0_5/PostgreSqlWriter.java	(working copy)
@@ -10,6 +10,7 @@
 import org.postgresql.geometric.PGpoint;
 
 import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
@@ -476,6 +477,13 @@
 	 * {@inheritDoc}
 	 */
 	public void process(RelationContainer relationContainer) {
+		// Ignore it
+	}
+	
+	/**
+	 * {@inheritDoc}
+	 */
+	public void process(BoundsContainer boundsContainer) {
 		// Do nothing.
 	}
 	
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/report/v0_5/EntityReporter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/report/v0_5/EntityReporter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/report/v0_5/EntityReporter.java	(working copy)
@@ -15,6 +15,7 @@
 import java.util.logging.Logger;
 
 import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
@@ -82,6 +83,10 @@
 		entityContainer.process(
 			new EntityProcessor() {
 				private UserStatistics processorUser = user;
+
+                public void process(BoundsContainer bounds) {
+	                // TODO Ignore it?
+                }
 				
 				public void process(NodeContainer node) {
 					processorUser.incrementNodeCount();
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/report/v0_5/IntegrityReporter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/report/v0_5/IntegrityReporter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/report/v0_5/IntegrityReporter.java	(working copy)
@@ -11,6 +11,7 @@
 import java.util.logging.Logger;
 
 import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
@@ -136,6 +137,14 @@
 	/**
 	 * {@inheritDoc}
 	 */
+    public void process(BoundsContainer bounds) {
+	    // TODO Just ignore the Bounds element?
+    }
+
+
+    /**
+	 * {@inheritDoc}
+	 */
 	public void process(NodeContainer node) {
 		nodeBitSet.set(node.getEntity().getId());
 	}
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/sort/common/MergingIterator.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/sort/common/MergingIterator.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/sort/common/MergingIterator.java	(working copy)
@@ -97,6 +97,10 @@
 				indexMinimum = indexCurrent;
 			}
 		}
+		/*
+		 * TODO: if there are two or more Bounds entities (which will currently compare as 
+		 * equal for the TypeThenId comparator), they should be merged with the union operation.
+		 */
 		
 		// Get the next entity from the source if available.
 		// Otherwise remove the source and its current data.
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/sort/v0_5/ChangeForSeekableApplierComparator.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/sort/v0_5/ChangeForSeekableApplierComparator.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/sort/v0_5/ChangeForSeekableApplierComparator.java	(working copy)
@@ -43,6 +43,7 @@
 		ChangeAction action = changeEntity.getAction();
 		Entity entity = changeEntity.getEntityContainer().getEntity();
 		
+		// TODO: Consider bound element?
 		if (entity.getType().equals(EntityType.Node)) {
 			if (action.equals(ChangeAction.Create)) {
 				return 1;
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/sort/v0_5/EntityByTypeThenIdComparator.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/sort/v0_5/EntityByTypeThenIdComparator.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/sort/v0_5/EntityByTypeThenIdComparator.java	(working copy)
@@ -26,6 +26,9 @@
 		if (typeDiff != 0) {
 			return typeDiff;
 		}
+
+		// TODO: All Bounds entities have the same id. Will that cause problems here?
+		// Maybe the Bounds id could be changed to an auto-incrementing number to prevent conflicts.
 		
 		// Perform an identifier comparison.
 		idDiff = o1.getEntity().getId() - o2.getEntity().getId();
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/BoundElementProcessor.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/BoundElementProcessor.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/BoundElementProcessor.java	(revision 0)
@@ -0,0 +1,91 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.xml.v0_5.impl;
+
+import org.xml.sax.Attributes;
+
+import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
+import com.bretth.osmosis.core.task.v0_5.Sink;
+import com.bretth.osmosis.core.xml.common.BaseElementProcessor;
+
+/**
+ * Provides an element processor implementation for a node.
+ * 
+ * @author Karl Newman
+ */
+public class BoundElementProcessor extends SourceElementProcessor {
+	private static final String ATTRIBUTE_NAME_BOX = "box";
+	private static final String ATTRIBUTE_NAME_ORIGIN = "origin";
+
+	private Bounds bound;
+
+
+	/**
+	 * Creates a new instance.
+	 * 
+	 * @param parentProcessor
+	 *            The parent of this element processor.
+	 * @param sink
+	 *            The sink for receiving processed data.
+	 * @param enableDateParsing
+	 *            If true, dates will be parsed from xml data, else the current date will be used
+	 *            thus saving parsing time.
+	 */
+	public BoundElementProcessor(BaseElementProcessor parentProcessor,
+	        Sink sink,
+	        boolean enableDateParsing) {
+		super(parentProcessor, sink, enableDateParsing);
+	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void begin(Attributes attributes) {
+		String boxString;
+		String origin;
+		String[] boundStrings;
+		Double right;
+		Double left;
+		Double top;
+		Double bottom;
+		
+		// TODO: Bounds element is not critical; may want to change these exceptions to fail
+		// silently
+		boxString = attributes.getValue(ATTRIBUTE_NAME_BOX);
+		
+		if (boxString == null) {
+			throw new OsmosisRuntimeException("Missing required box attribute of bound element");
+		}
+		boundStrings = boxString.split(",");
+		if (boundStrings.length != 4) {
+			throw new OsmosisRuntimeException("Badly formed box attribute of bound element");
+		}
+		try {
+			bottom = Double.parseDouble(boundStrings[0]);
+			left = Double.parseDouble(boundStrings[1]);
+			top = Double.parseDouble(boundStrings[2]);
+			right = Double.parseDouble(boundStrings[3]);
+		} catch (NumberFormatException e) {
+			throw new OsmosisRuntimeException("Can't parse box attribute of bound element", e);
+		}
+		origin = attributes.getValue(ATTRIBUTE_NAME_ORIGIN);
+		if (origin == null || origin.equals("")) {
+			throw new OsmosisRuntimeException("Origin attribute of bound element is empty or missing.");
+		}
+		bound = new Bounds(right, left, top, bottom, origin);
+	}
+
+
+	/**
+	 * {@inheritDoc}
+	 */
+	@Override
+	public void end() {
+		getSink().process(new BoundsContainer(bound));
+		bound = null;
+	}
+
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\src\com\bretth\osmosis\core\xml\v0_5\impl\BoundElementProcessor.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/BoundsWriter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/BoundsWriter.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/BoundsWriter.java	(revision 0)
@@ -0,0 +1,52 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.xml.v0_5.impl;
+
+import java.util.Locale;
+
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
+import com.bretth.osmosis.core.xml.common.ElementWriter;
+
+/**
+ * @author KNewman
+ * 
+ */
+public class BoundsWriter extends ElementWriter {
+
+	/**
+	 * Creates a new instance.
+	 * 
+	 * @param elementName
+	 *            The name of the element to be written.
+	 * @param indentLevel
+	 *            The indent level of the element.
+	 */
+	public BoundsWriter(String elementName, int indentLevel) {
+		super(elementName, indentLevel);
+	}
+
+
+	/**
+	 * Writes the bounds.
+	 * 
+	 * @param bounds
+	 *            The bounds to be processed.
+	 */
+	public void process(Bounds bounds) {
+
+		// Only add the Bounds if the origin string isn't empty
+		if (bounds.getOrigin() != "") {
+			beginOpenElement();
+			// Write with the US locale (to force . instead of , as the decimal separator)
+			// Use only 5 decimal places (~1.2 meter resolution should be sufficient for Bounds)
+			addAttribute("box", String.format(
+			        Locale.US,
+			        "%.5f,%.5f,%.5f,%.5f",
+			        bounds.getBottom(),
+			        bounds.getLeft(),
+			        bounds.getTop(),
+			        bounds.getRight()));
+			addAttribute("origin", bounds.getOrigin());
+			endOpenElement(true);
+		}
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\src\com\bretth\osmosis\core\xml\v0_5\impl\BoundsWriter.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/OsmElementProcessor.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/OsmElementProcessor.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/OsmElementProcessor.java	(working copy)
@@ -5,6 +5,7 @@
 
 import org.xml.sax.Attributes;
 
+import com.bretth.osmosis.core.OsmosisRuntimeException;
 import com.bretth.osmosis.core.task.v0_5.Sink;
 import com.bretth.osmosis.core.xml.common.BaseElementProcessor;
 import com.bretth.osmosis.core.xml.common.ElementProcessor;
@@ -19,6 +20,7 @@
 	
 	private static final Logger log = Logger.getLogger(OsmElementProcessor.class.getName());
 	
+	private static final String ELEMENT_NAME_BOUND = "bound";
 	private static final String ELEMENT_NAME_NODE = "node";
 	private static final String ELEMENT_NAME_WAY = "way";
 	private static final String ELEMENT_NAME_RELATION = "relation";
@@ -25,6 +27,7 @@
 	private static final String ATTRIBUTE_NAME_VERSION = "version";
 	
 	
+	private BoundElementProcessor boundElementProcessor;
 	private NodeElementProcessor nodeElementProcessor;
 	private WayElementProcessor wayElementProcessor;
 	private RelationElementProcessor relationElementProcessor;
@@ -29,6 +32,9 @@
 	private WayElementProcessor wayElementProcessor;
 	private RelationElementProcessor relationElementProcessor;
 	
+	private boolean foundBounds = false;
+	private boolean foundEntities = false;
+	
 	
 	/**
 	 * Creates a new instance.
@@ -44,6 +50,7 @@
 	public OsmElementProcessor(BaseElementProcessor parentProcessor, Sink sink, boolean enableDateParsing) {
 		super(parentProcessor, sink, enableDateParsing);
 		
+		boundElementProcessor = new BoundElementProcessor(this, getSink(), enableDateParsing);
 		nodeElementProcessor = new NodeElementProcessor(this, getSink(), enableDateParsing);
 		wayElementProcessor = new WayElementProcessor(this, getSink(), enableDateParsing);
 		relationElementProcessor = new RelationElementProcessor(this, getSink(), enableDateParsing);
@@ -81,11 +88,23 @@
 	 */
 	@Override
 	public ElementProcessor getChild(String uri, String localName, String qName) {
-		if (ELEMENT_NAME_NODE.equals(qName)) {
+		if (ELEMENT_NAME_BOUND.equals(qName)) {
+			if (foundEntities) {
+				throw new OsmosisRuntimeException("bound element must come before any entities");
+			}
+			if (foundBounds) {
+				throw new OsmosisRuntimeException("Only one bound element allowed");
+			}
+			foundBounds = true;
+			return boundElementProcessor;
+		} else if (ELEMENT_NAME_NODE.equals(qName)) {
+			foundEntities = true;
 			return nodeElementProcessor;
 		} else if (ELEMENT_NAME_WAY.equals(qName)) {
+			foundEntities = true;
 			return wayElementProcessor;
 		} else if (ELEMENT_NAME_RELATION.equals(qName)) {
+			foundEntities = true;
 			return relationElementProcessor;
 		}
 		
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/OsmWriter.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/OsmWriter.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/impl/OsmWriter.java	(working copy)
@@ -4,6 +4,8 @@
 import java.io.BufferedWriter;
 
 import com.bretth.osmosis.core.OsmosisConstants;
+import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityContainer;
 import com.bretth.osmosis.core.container.v0_5.EntityProcessor;
 import com.bretth.osmosis.core.container.v0_5.NodeContainer;
@@ -91,7 +93,9 @@
 		private NodeWriter nodeWriter;
 		private WayWriter wayWriter;
 		private RelationWriter relationWriter;
-		
+		private BoundsWriter boundsWriter;
+		private boolean boundsWritten = false; // can't write a Bounds twice
+		private boolean entitiesWritten = false; // can't write a Bounds after any Entities
 		
 		/**
 		 * Creates a new instance.
@@ -103,6 +107,7 @@
 			nodeWriter = new NodeWriter("node", indentLevel);
 			wayWriter = new WayWriter("way", indentLevel);
 			relationWriter = new RelationWriter("relation", indentLevel);
+			boundsWriter = new BoundsWriter("bound", indentLevel);
 		}
 		
 		
@@ -116,6 +121,10 @@
 			nodeWriter.setWriter(writer);
 			wayWriter.setWriter(writer);
 			relationWriter.setWriter(writer);
+			boundsWriter.setWriter(writer);
+			// reset the flags indicating which data has been written
+			boundsWritten = false;
+			entitiesWritten = false;
 		}
 		
 		
@@ -124,6 +133,7 @@
 		 */
 		public void process(NodeContainer node) {
 			nodeWriter.process(node.getEntity());
+			entitiesWritten = true;
 		}
 		
 		
@@ -132,6 +142,7 @@
 		 */
 		public void process(WayContainer way) {
 			wayWriter.process(way.getEntity());
+			entitiesWritten = true;
 		}
 		
 		
@@ -140,6 +151,22 @@
 		 */
 		public void process(RelationContainer relation) {
 			relationWriter.process(relation.getEntity());
+			entitiesWritten = true;
 		}
+
+
+		/**
+		 * {@inheritDoc}
+		 */
+        public void process(BoundsContainer bounds) {
+    		if (boundsWritten) {
+    			throw new OsmosisRuntimeException("bound element already written; only one allowed");
+    		}
+    		if (entitiesWritten) {
+    			throw new OsmosisRuntimeException("Can't write bound element after other entities");    			
+    		}
+        	boundsWriter.process(bounds.getEntity());
+    		boundsWritten = true;
+        }
 	}
 }
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/XmlDownloader.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/XmlDownloader.java	(revision 6582)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/src/com/bretth/osmosis/core/xml/v0_5/XmlDownloader.java	(working copy)
@@ -19,6 +19,8 @@
 import org.xml.sax.SAXParseException;
 
 import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
 import com.bretth.osmosis.core.task.v0_5.RunnableSource;
 import com.bretth.osmosis.core.task.v0_5.Sink;
 import com.bretth.osmosis.core.xml.v0_5.impl.OsmHandler;
@@ -178,6 +180,9 @@
             SAXParser    parser = createParser();
             InputStream  inputStream = getInputStream(myBaseUrl + "/map?bbox=" + myLeft + "," + myBottom + "," + myRight + "," + myTop);
 
+            // First send the Bounds down the pipeline
+            mySink.process(new BoundsContainer(new Bounds(myRight, myLeft, myTop, myBottom, myBaseUrl)));
+
             try {
                 parser.parse(inputStream, new OsmHandler(mySink, true));
             } finally {
Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/domain/v0_5/BoundsTest.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/domain/v0_5/BoundsTest.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/domain/v0_5/BoundsTest.java	(revision 0)
@@ -0,0 +1,589 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.domain.v0_5;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class BoundsTest {
+
+	/**
+	 * Test the constructor with right > 180.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor1() {
+		new Bounds(180.0000000000001, -20, 20, -20, "not null");
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test the constructor with right < -180.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor2() {
+		new Bounds(-180.0000000000001, -20, 20, -20, "not null");
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test the constructor with left > 180.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor3() {
+		new Bounds(20, 180.0000000000001, 20, -20, "not null");
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test the constructor with left < -180.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor4() {
+		new Bounds(20, -180.0000000000001, 20, -20, "not null");
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test the constructor with top > 90.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor5() {
+		new Bounds(20, -20, 90.0000000000001, -20, "not null");
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test the constructor with top < -90.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor6() {
+		new Bounds(20, -20, -90.0000000000001, -91, "not null");
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test the constructor with bottom > 90.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor7() {
+		new Bounds(20, -20, 91, 90.0000000000001, "not null");
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test the constructor with bottom < -90.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor8() {
+		new Bounds(20, -20, 20, -90.0000000000001, "not null");
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test the constructor with top < bottom.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor9() {
+		new Bounds(20, -20, -20, 20, "not null");
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test the constructor with null origin string.
+	 */
+	@Test(expected = IllegalArgumentException.class)
+	public final void testConstructor10() {
+		new Bounds(20, -20, 20, -20, null);
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test a valid constructor with only the origin string provided (covers full planet).
+	 */
+	@Test
+	public final void testConstructor11() {
+		Bounds b = new Bounds("not null");
+		assertTrue(Double.compare(b.getRight(), 180) == 0
+		        && Double.compare(b.getLeft(), -180) == 0
+		        && Double.compare(b.getTop(), 90) == 0
+		        && Double.compare(b.getBottom(), -90) == 0
+		        && b.getOrigin().equals("not null"));
+	}
+
+
+	/**
+	 * Test a valid constructor with all values provided.
+	 */
+	@Test
+	public final void testConstructor12() {
+		Bounds b = new Bounds(20, -20, 21, -21, "not null");
+		assertTrue(Double.compare(b.getRight(), 20) == 0
+		        && Double.compare(b.getLeft(), -20) == 0
+		        && Double.compare(b.getTop(), 21) == 0
+		        && Double.compare(b.getBottom(), -21) == 0
+		        && b.getOrigin().equals("not null"));
+	}
+
+
+	/**
+	 * Test a simple intersection.
+	 */
+	@Test
+	public final void testIntersect1() {
+		final double right1 = 20.0;
+		final double left1 = 10.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 30.0;
+		final double left2 = 15.0;
+		final double top2 = 45.0;
+		final double bottom2 = 20.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "this");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "that");
+		Bounds b = b1.intersect(b2);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0
+		        && b.getOrigin().equals("this"));
+		// Test it with arguments swapped
+		b = b2.intersect(b1);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0
+		        && b.getOrigin().equals("that"));
+	}
+
+
+	/**
+	 * Test an intersect with no top-bottom overlapping areas.
+	 */
+	@Test
+	public final void testIntersect2() {
+		final double right1 = 20.0;
+		final double left1 = 10.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 30.0;
+		final double left2 = 15.0;
+		final double top2 = 25.0;
+		final double bottom2 = 20.0;
+		Bounds b = new Bounds(right1, left1, top1, bottom1, "").intersect(new Bounds(
+		        right2,
+		        left2,
+		        top2,
+		        bottom2,
+		        ""));
+		assertNull(b);
+	}
+
+
+	/**
+	 * Test an intersect with no left-right overlapping areas.
+	 */
+	@Test
+	public final void testIntersect3() {
+		final double right1 = 20.0;
+		final double left1 = 10.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 30.0;
+		final double left2 = 21.0;
+		final double top2 = 45.0;
+		final double bottom2 = 20.0;
+		Bounds b = new Bounds(right1, left1, top1, bottom1, "").intersect(new Bounds(
+		        right2,
+		        left2,
+		        top2,
+		        bottom2,
+		        ""));
+		assertNull(b);
+	}
+
+
+	/**
+	 * Test an intersect with 1 Bounds crossing the antimeridian.
+	 */
+	@Test
+	public final void testIntersect4() {
+		final double right1 = 20.0;
+		final double left1 = 60.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 30.0;
+		final double left2 = 15.0;
+		final double top2 = 45.0;
+		final double bottom2 = 20.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "that");
+		Bounds b = b1.intersect(b2);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0
+		        && b.getOrigin().equals("that"));
+		// Test it with arguments swapped
+		b = b2.intersect(b1);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0
+		        && b.getOrigin().equals("that"));
+	}
+
+
+	/**
+	 * Test an intersection where one Bounds crosses the antimeridian (but doesn't cover the planet)
+	 * and both ends overlap with the intersecting Bounds. A strict intersection would result in two
+	 * Bounds areas, so just expect the smaller (longitudinally) of the Bounds as the result.
+	 */
+	@Test
+	public final void testIntersect5() {
+		final double right1 = 150.0;
+		final double left1 = 170.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 175.0;
+		final double left2 = 145.0;
+		final double top2 = 45.0;
+		final double bottom2 = 25.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "");
+		Bounds b = b1.intersect(b2);
+		assertTrue(Double.compare(b.getRight(), right2) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0);
+		// Test it with arguments swapped
+		b = b2.intersect(b1);
+		assertTrue(Double.compare(b.getRight(), right2) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0);
+	}
+
+
+	/**
+	 * Test an intersect with both Bounds crossing the antimeridian.
+	 */
+	@Test
+	public final void testIntersect6() {
+		final double right1 = 20.0;
+		final double left1 = 60.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 30.0;
+		final double left2 = 50.0;
+		final double top2 = 45.0;
+		final double bottom2 = 35.0;
+		Bounds b = new Bounds(right1, left1, top1, bottom1, "").intersect(new Bounds(
+		        right2,
+		        left2,
+		        top2,
+		        bottom2,
+		        ""));
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left1) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom2) == 0);
+	}
+
+
+	/**
+	 * Test a simple union on opposite sides of the planet with exactly the same distance between
+	 * them on both sides. The smallest resulting union could wrap around the planet either way, so
+	 * expect a simple Bounds which does not cross the antimeridian.
+	 */
+	@Test
+	public final void testUnion1() {
+		final double right1 = 90.0;
+		final double left1 = 80.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = -90.0;
+		final double left2 = -100.0;
+		final double top2 = 45.0;
+		final double bottom2 = 35.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "this");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "that");
+		Bounds b = b1.union(b2);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top2) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0
+		        && b.getOrigin().equals("this"));
+		// Test it with arguments swapped
+		b = b2.union(b1);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top2) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0
+		        && b.getOrigin().equals("that"));
+	}
+
+
+	/**
+	 * Test a union where one Bounds is entirely contained by another.
+	 */
+	@Test
+	public final void testUnion2() {
+		final double right1 = 20.0;
+		final double left1 = 10.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 15.0;
+		final double left2 = 12.0;
+		final double top2 = 35.0;
+		final double bottom2 = 32.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "that");
+		Bounds b = b1.union(b2);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left1) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0
+		        && b.getOrigin().equals("that"));
+		// Test it with arguments swapped
+		b = b2.union(b1);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left1) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0
+		        && b.getOrigin().equals("that"));
+	}
+
+
+	/**
+	 * Test a union of two simple Bounds where the resulting Bounds crosses the antimeridian.
+	 */
+	@Test
+	public final void testUnion3() {
+		final double right1 = 91.0;
+		final double left1 = 80.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = -90.0;
+		final double left2 = -100.0;
+		final double top2 = 45.0;
+		final double bottom2 = 35.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "");
+		Bounds b = b1.union(b2);
+		assertTrue(Double.compare(b.getRight(), right2) == 0
+		        && Double.compare(b.getLeft(), left1) == 0
+		        && Double.compare(b.getTop(), top2) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0);
+		// Test it with arguments swapped
+		b = b2.union(b1);
+		assertTrue(Double.compare(b.getRight(), right2) == 0
+		        && Double.compare(b.getLeft(), left1) == 0
+		        && Double.compare(b.getTop(), top2) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0);
+	}
+
+
+	/**
+	 * Test a union where one Bounds crosses the antimeridian but there is still a gap such that the
+	 * union does not cover the planet.
+	 */
+	@Test
+	public final void testUnion4() {
+		final double right1 = 10.0;
+		final double left1 = 20.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 15.0;
+		final double left2 = 12.0;
+		final double top2 = 35.0;
+		final double bottom2 = 32.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "");
+		Bounds b = b1.union(b2);
+		assertTrue(Double.compare(b.getRight(), right2) == 0
+		        && Double.compare(b.getLeft(), left1) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0);
+		// Test it with arguments swapped
+		b = b2.union(b1);
+		assertTrue(Double.compare(b.getRight(), right2) == 0
+		        && Double.compare(b.getLeft(), left1) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0);
+	}
+
+
+	/**
+	 * Test a union where both Bounds cross the antimeridian but do not cover the planet.
+	 */
+	@Test
+	public final void testUnion5() {
+		final double right1 = -170.0;
+		final double left1 = 175.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = -175.0;
+		final double left2 = 170.0;
+		final double top2 = 35.0;
+		final double bottom2 = 25.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "");
+		Bounds b = b1.union(b2);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom2) == 0);
+		// Test it with arguments swapped
+		b = b2.union(b1);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left2) == 0
+		        && Double.compare(b.getTop(), top1) == 0
+		        && Double.compare(b.getBottom(), bottom2) == 0);
+	}
+
+
+	/**
+	 * Test a union where one Bounds covers the planet left-right.
+	 */
+	@Test
+	public final void testUnion6() {
+		final double right1 = 180.0;
+		final double left1 = -180.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 15.0;
+		final double left2 = 12.0;
+		final double top2 = 45.0;
+		final double bottom2 = 32.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "");
+		Bounds b = b1.union(b2);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left1) == 0
+		        && Double.compare(b.getTop(), top2) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0);
+		// Test it with arguments swapped
+		b = b2.union(b1);
+		assertTrue(Double.compare(b.getRight(), right1) == 0
+		        && Double.compare(b.getLeft(), left1) == 0
+		        && Double.compare(b.getTop(), top2) == 0
+		        && Double.compare(b.getBottom(), bottom1) == 0);
+	}
+
+
+	/**
+	 * Test a union where the Bounds overlap and the resulting union covers the planet left-right.
+	 */
+	@Test
+	public final void testUnion7() {
+		final double right1 = 150.0;
+		final double left1 = 170.0;
+		final double top1 = 40.0;
+		final double bottom1 = 30.0;
+		final double right2 = 175.0;
+		final double left2 = 145.0;
+		final double top2 = 45.0;
+		final double bottom2 = 25.0;
+		final double MIN_LONGITUDE = -180.0;
+		final double MAX_LONGITUDE = 180.0;
+
+		Bounds b1 = new Bounds(right1, left1, top1, bottom1, "");
+		Bounds b2 = new Bounds(right2, left2, top2, bottom2, "");
+		Bounds b = b1.union(b2);
+		assertTrue(Double.compare(b.getRight(), MAX_LONGITUDE) == 0
+		        && Double.compare(b.getLeft(), MIN_LONGITUDE) == 0
+		        && Double.compare(b.getTop(), top2) == 0
+		        && Double.compare(b.getBottom(), bottom2) == 0);
+		// Test it with arguments swapped
+		b = b2.union(b1);
+		assertTrue(Double.compare(b.getRight(), MAX_LONGITUDE) == 0
+		        && Double.compare(b.getLeft(), MIN_LONGITUDE) == 0
+		        && Double.compare(b.getTop(), top2) == 0
+		        && Double.compare(b.getBottom(), bottom2) == 0);
+	}
+
+
+	/**
+	 * Test the case where the Bounds is already "simple" (i.e., doesn't cross the antimeridian)
+	 */
+	@Test
+	public final void testToSimpleBounds1() {
+		final double left = -179.0;
+		final double right = 179.0;
+		final double top = 1.0;
+		final double bottom = -1.0;
+		boolean expected1found = false;
+		int cnt = 0;
+		Bounds expected1 = new Bounds(right, left, top, bottom, "");
+
+		for (Bounds b : new Bounds(right, left, top, bottom, "").toSimpleBounds()) {
+			cnt++;
+			if (Double.compare(b.getRight(), expected1.getRight()) == 0
+			        && Double.compare(b.getLeft(), expected1.getLeft()) == 0
+			        && Double.compare(b.getTop(), expected1.getTop()) == 0
+			        && Double.compare(b.getBottom(), expected1.getBottom()) == 0) {
+				expected1found = true;
+			}
+		}
+		assertTrue(cnt == 1);
+		assertTrue(expected1found);
+	}
+
+
+	/**
+	 * Test the case where the Bounds is split into two simple Bounds elements, one on either side
+	 * of the antimeridian.
+	 */
+	@Test
+	public final void testToSimpleBounds2() {
+		final double left = 179.0;
+		final double right = -179.0;
+		final double top = 1.0;
+		final double bottom = -1.0;
+		final double MIN_LONGITUDE = -180.0;
+		final double MAX_LONGITUDE = 180.0;
+		boolean expected1found = false, expected2found = false;
+		int cnt = 0;
+		Bounds expected1 = new Bounds(MAX_LONGITUDE, left, top, bottom, "");
+		Bounds expected2 = new Bounds(right, MIN_LONGITUDE, top, bottom, "");
+
+		for (Bounds b : new Bounds(right, left, top, bottom, "").toSimpleBounds()) {
+			cnt++;
+			if (Double.compare(b.getRight(), expected1.getRight()) == 0
+			        && Double.compare(b.getLeft(), expected1.getLeft()) == 0
+			        && Double.compare(b.getTop(), expected1.getTop()) == 0
+			        && Double.compare(b.getBottom(), expected1.getBottom()) == 0) {
+				expected1found = true;
+			}
+			if (Double.compare(b.getRight(), expected2.getRight()) == 0
+			        && Double.compare(b.getLeft(), expected2.getLeft()) == 0
+			        && Double.compare(b.getTop(), expected2.getTop()) == 0
+			        && Double.compare(b.getBottom(), expected2.getBottom()) == 0) {
+				expected2found = true;
+			}
+		}
+
+		assertTrue(cnt == 2);
+		assertTrue(expected1found);
+		assertTrue(expected2found);
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\core\domain\v0_5\BoundsTest.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/AreaFilterTest.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/AreaFilterTest.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/AreaFilterTest.java	(revision 0)
@@ -0,0 +1,543 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.filter.v0_5;
+
+import static org.junit.Assert.*;
+
+import java.util.Date;
+import java.util.Iterator;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.bretth.osmosis.core.container.v0_5.*;
+import com.bretth.osmosis.core.domain.v0_5.*;
+import com.bretth.osmosis.core.filter.common.IdTrackerType;
+import com.bretth.osmosis.test.task.SinkEntityInspector;
+
+public class AreaFilterTest {
+
+	private static final String TEST_USER = "OsmosisTest";
+	private SinkEntityInspector entityInspector;
+	private AreaFilter simpleAreaFilter;
+	private AreaFilter simpleCompleteWayFilter;
+	private AreaFilter simpleCompleteRelationFilter;
+	private AreaFilter simpleCompleteWayRelationFilter;
+	private Node inAreaNode;
+	private Node outOfAreaNode;
+	private Node inAreaWayNode1;
+	private Node inAreaWayNode2;
+	private Node outOfAreaWayNode1;
+	private Node outOfAreaWayNode2;
+	private Way inAreaWay;
+	private Way outOfAreaWay;
+	private Way inOutWay;
+	private Way mangledInOutWay1;
+	private Way mangledInOutWay2;
+	private Relation inAreaRelation;
+	private Relation outOfAreaRelation1;
+	private Relation inOutRelation1;
+	private Relation inOutRelation2;
+	private Relation mangledInOutRelation1;
+	private Relation mangledInOutRelation2;
+	private Relation mangledCompleteInOutRelation1;
+
+
+	@Before
+	public void setUp() throws Exception {
+		setUpFilters();
+		setUpNodes();
+		setUpWays();
+		setUpRelations();
+	}
+
+
+	private void setUpFilters() {
+		// TODO: Might want to create an inspection interface for entityInspector and then use a
+		// factory to create the instance
+		entityInspector = new SinkEntityInspector();
+		// simpleAreaFilter doesn't cross antimeridian; no complete ways or relations
+		simpleAreaFilter = new BoundingBoxFilter(
+		        IdTrackerType.IdList,
+		        -20,
+		        20,
+		        20,
+		        -20,
+		        false,
+		        false);
+		// simpleCompleteWayFilter doesn't cross antimeridian; complete ways but not relations
+		simpleCompleteWayFilter = new BoundingBoxFilter(
+		        IdTrackerType.IdList,
+		        -20,
+		        20,
+		        20,
+		        -20,
+		        true,
+		        false);
+		// simpleCompleteRelationFilter doesn't cross antimeridian; complete ways but not relations
+		simpleCompleteRelationFilter = new BoundingBoxFilter(
+		        IdTrackerType.IdList,
+		        -20,
+		        20,
+		        20,
+		        -20,
+		        false,
+		        true);
+		// simpleCompleteWayRelationFilter doesn't cross antimeridian; complete ways and relations
+		simpleCompleteWayRelationFilter = new BoundingBoxFilter(
+		        IdTrackerType.IdList,
+		        -20,
+		        20,
+		        20,
+		        -20,
+		        true,
+		        true);
+		simpleAreaFilter.setSink(entityInspector);
+		simpleCompleteWayFilter.setSink(entityInspector);
+		simpleCompleteRelationFilter.setSink(entityInspector);
+		simpleCompleteWayRelationFilter.setSink(entityInspector);
+	}
+
+
+	private void setUpNodes() {
+		inAreaNode = new Node(1234, new Date(), TEST_USER, 10, 10);
+		inAreaNode.addTag(new Tag("test_key1", "test_value1"));
+		outOfAreaNode = new Node(1235, new Date(), TEST_USER, 30, 30);
+		inAreaWayNode1 = new Node(2345, new Date(), TEST_USER, 10, 10);
+		inAreaWayNode2 = new Node(2346, new Date(), TEST_USER, -10, -10);
+		outOfAreaWayNode1 = new Node(2347, new Date(), TEST_USER, -30, -30);
+		outOfAreaWayNode2 = new Node(2348, new Date(), TEST_USER, -40, -40);
+	}
+
+
+	private void setUpWays() {
+		inAreaWay = new Way(3456, new Date(), TEST_USER);
+		inAreaWay.addWayNode(new WayNode(inAreaWayNode1.getId()));
+		inAreaWay.addWayNode(new WayNode(inAreaWayNode2.getId()));
+		inAreaWay.addTag(new Tag("test_key2", "test_value2"));
+		outOfAreaWay = new Way(3457, new Date(), TEST_USER);
+		outOfAreaWay.addWayNode(new WayNode(outOfAreaWayNode1.getId()));
+		outOfAreaWay.addWayNode(new WayNode(outOfAreaWayNode2.getId()));
+		inOutWay = new Way(3458, new Date(), TEST_USER);
+		inOutWay.addWayNode(new WayNode(inAreaWayNode1.getId()));
+		inOutWay.addWayNode(new WayNode(outOfAreaWayNode1.getId()));
+		inOutWay.addWayNode(new WayNode(inAreaWayNode2.getId()));
+		inOutWay.addWayNode(new WayNode(outOfAreaWayNode2.getId()));
+		inOutWay.addTag(new Tag("test_key3", "test_value3"));
+		// mangledInOutWay1 is mangled by completeWays=false
+		mangledInOutWay1 = new Way(inOutWay.getId(), inOutWay.getTimestamp(), inOutWay.getUser());
+		mangledInOutWay1.addWayNode(new WayNode(inAreaWayNode1.getId()));
+		mangledInOutWay1.addWayNode(new WayNode(inAreaWayNode2.getId()));
+		mangledInOutWay1.addTags(inOutWay.getTagList());
+		// mangledInOutWay2 is mangled by completeRelations=false
+		mangledInOutWay2 = new Way(inOutWay.getId(), inOutWay.getTimestamp(), inOutWay.getUser());
+		mangledInOutWay2.addWayNode(new WayNode(inAreaWayNode1.getId()));
+		mangledInOutWay2.addWayNode(new WayNode(inAreaWayNode2.getId()));
+		mangledInOutWay2.addWayNode(new WayNode(outOfAreaWayNode2.getId()));
+	}
+
+
+	private void setUpRelations() {
+		inAreaRelation = new Relation(4567, new Date(), TEST_USER);
+		inAreaRelation.addMember(new RelationMember(
+		        inAreaWayNode1.getId(),
+		        EntityType.Node,
+		        "node1"));
+		inAreaRelation.addMember(new RelationMember(
+		        inAreaWayNode2.getId(),
+		        EntityType.Node,
+		        "node2"));
+		inAreaRelation.addMember(new RelationMember(inAreaWay.getId(), EntityType.Way, "way1"));
+		inAreaRelation.addTag(new Tag("test_key4", "test_value4"));
+		outOfAreaRelation1 = new Relation(4568, new Date(), TEST_USER);
+		outOfAreaRelation1.addMember(new RelationMember(
+		        outOfAreaWayNode1.getId(),
+		        EntityType.Node,
+		        "node1"));
+		outOfAreaRelation1.addMember(new RelationMember(
+		        outOfAreaWayNode2.getId(),
+		        EntityType.Node,
+		        "node2"));
+		outOfAreaRelation1.addMember(new RelationMember(
+		        outOfAreaWay.getId(),
+		        EntityType.Way,
+		        "way1"));
+		inOutRelation2 = new Relation(4570, new Date(), TEST_USER);
+		inOutRelation2.addMember(new RelationMember(
+		        inAreaWayNode2.getId(),
+		        EntityType.Node,
+		        "node1"));
+		inOutRelation2.addMember(new RelationMember(
+		        outOfAreaWayNode2.getId(),
+		        EntityType.Node,
+		        "node2"));
+		inOutRelation2.addMember(new RelationMember(inOutWay.getId(), EntityType.Way, "way1"));
+		inOutRelation2.addTag(new Tag("test_key5", "test_value5"));
+		inOutRelation1 = new Relation(4569, new Date(), TEST_USER);
+		inOutRelation1.addMember(new RelationMember(
+		        inAreaWayNode1.getId(),
+		        EntityType.Node,
+		        "node1"));
+		inOutRelation1.addMember(new RelationMember(
+		        outOfAreaWayNode1.getId(),
+		        EntityType.Node,
+		        "node2"));
+		inOutRelation1.addMember(new RelationMember(inOutWay.getId(), EntityType.Way, "way1"));
+		inOutRelation1.addMember(new RelationMember(
+		        inOutRelation2.getId(),
+		        EntityType.Relation,
+		        "relation1"));
+		inOutRelation1.addTag(new Tag("test_key4", "test_value4"));
+		mangledInOutRelation1 = new Relation(
+		        inOutRelation1.getId(),
+		        inOutRelation1.getTimestamp(),
+		        inOutRelation1.getUser());
+		mangledInOutRelation1.addMember(new RelationMember(
+		        inAreaWayNode1.getId(),
+		        EntityType.Node,
+		        "node1"));
+		mangledInOutRelation1.addMember(new RelationMember(inOutWay.getId(), EntityType.Way, "way1"));
+		mangledInOutRelation1.addTags(inOutRelation1.getTagList());
+		mangledInOutRelation2 = new Relation(
+		        inOutRelation2.getId(),
+		        inOutRelation2.getTimestamp(),
+		        inOutRelation2.getUser());
+		mangledInOutRelation2.addMember(new RelationMember(
+		        inAreaWayNode2.getId(),
+		        EntityType.Node,
+		        "node1"));
+		mangledInOutRelation2.addMember(new RelationMember(inOutWay.getId(), EntityType.Way, "way1"));
+		mangledInOutRelation2.addTags(inOutRelation2.getTagList());
+		mangledCompleteInOutRelation1 = new Relation(
+		        inOutRelation1.getId(),
+		        inOutRelation1.getTimestamp(),
+		        inOutRelation1.getUser());
+		mangledCompleteInOutRelation1.addMember(new RelationMember(
+		        inAreaWayNode1.getId(),
+		        EntityType.Node,
+		        "node1"));
+		mangledCompleteInOutRelation1.addMember(new RelationMember(
+		        inOutWay.getId(),
+		        EntityType.Way,
+		        "way1"));
+		mangledCompleteInOutRelation1.addTags(inOutRelation1.getTagList());
+		mangledCompleteInOutRelation1.addMember(new RelationMember(
+		        inOutRelation2.getId(),
+		        EntityType.Relation,
+		        "relation1"));
+	}
+
+
+	@After
+	public void tearDown() throws Exception {
+		simpleAreaFilter.release();
+		simpleCompleteWayFilter.release();
+		simpleCompleteRelationFilter.release();
+		simpleCompleteWayRelationFilter.release();
+	}
+
+
+	/**
+	 * Test simple passing of a node that falls within the area.
+	 */
+	@Test
+	public final void testProcessNodeContainer1() {
+		Entity compareNode;
+
+		simpleAreaFilter.process(new NodeContainer(inAreaNode));
+		simpleAreaFilter.complete();
+
+		compareNode = entityInspector.getLastEntityContainer().getEntity();
+		assertTrue(compareNode instanceof Node && inAreaNode.compareTo((Node)compareNode) == 0);
+	}
+
+
+	/**
+	 * Test simple non-passing of node that falls outside the area.
+	 */
+	@Test
+	public final void testProcessNodeContainer2() {
+		simpleAreaFilter.process(new NodeContainer(outOfAreaNode));
+		simpleAreaFilter.complete();
+		assertNull(entityInspector.getLastEntityContainer());
+	}
+
+
+	/**
+	 * Test passing of nodes and ways strictly inside the area with completeWays = false.
+	 */
+	@Test
+	public final void testProcessWayContainer1() {
+		Iterator<EntityContainer> ecIterator;
+
+		simpleAreaFilter.process(new NodeContainer(inAreaWayNode1));
+		simpleAreaFilter.process(new NodeContainer(inAreaWayNode2));
+		simpleAreaFilter.process(new WayContainer(inAreaWay));
+		simpleAreaFilter.complete();
+
+		ecIterator = entityInspector.getProcessedEntities().iterator();
+		assertTrue(inAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWay.compareTo((Way)ecIterator.next().getEntity()) == 0
+		        && !ecIterator.hasNext());
+	}
+
+
+	/**
+	 * Test non-passing of nodes and ways which are strictly outside the area with completeWays =
+	 * false.
+	 */
+	@Test
+	public final void testProcessWayContainer2() {
+		simpleAreaFilter.process(new NodeContainer(outOfAreaWayNode1));
+		simpleAreaFilter.process(new NodeContainer(outOfAreaWayNode2));
+		simpleAreaFilter.process(new WayContainer(outOfAreaWay));
+		simpleAreaFilter.complete();
+
+		assertNull(entityInspector.getLastEntityContainer());
+	}
+
+
+	/**
+	 * Test mangling of a way which has nodes both inside and outside the area with completeWays =
+	 * false.
+	 */
+	@Test
+	public final void testProcessWayContainer3() {
+		Iterator<EntityContainer> ecIterator;
+
+		simpleAreaFilter.process(new NodeContainer(inAreaWayNode1));
+		simpleAreaFilter.process(new NodeContainer(inAreaWayNode2));
+		simpleAreaFilter.process(new NodeContainer(outOfAreaWayNode1));
+		simpleAreaFilter.process(new NodeContainer(outOfAreaWayNode2));
+		simpleAreaFilter.process(new WayContainer(inOutWay));
+		simpleAreaFilter.complete();
+
+		ecIterator = entityInspector.getProcessedEntities().iterator();
+		assertTrue(inAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && mangledInOutWay1.compareTo((Way)ecIterator.next().getEntity()) == 0
+		        && !ecIterator.hasNext());
+	}
+
+
+	/**
+	 * Test passing of nodes and ways strictly inside the area with completeWays = true.
+	 */
+	@Test
+	public final void testProcessWayContainer4() {
+		Iterator<EntityContainer> ecIterator;
+
+		simpleCompleteWayFilter.process(new NodeContainer(inAreaWayNode1));
+		simpleCompleteWayFilter.process(new NodeContainer(inAreaWayNode2));
+		simpleCompleteWayFilter.process(new WayContainer(inAreaWay));
+		simpleCompleteWayFilter.complete();
+
+		ecIterator = entityInspector.getProcessedEntities().iterator();
+		assertTrue(inAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWay.compareTo((Way)ecIterator.next().getEntity()) == 0
+		        && !ecIterator.hasNext());
+	}
+
+
+	/**
+	 * Test non-passing of nodes and ways which are strictly outside the area with completeWays =
+	 * true.
+	 */
+	@Test
+	public final void testProcessWayContainer5() {
+		simpleCompleteWayFilter.process(new NodeContainer(outOfAreaWayNode1));
+		simpleCompleteWayFilter.process(new NodeContainer(outOfAreaWayNode2));
+		simpleCompleteWayFilter.process(new WayContainer(outOfAreaWay));
+		simpleCompleteWayFilter.complete();
+
+		assertNull(entityInspector.getLastEntityContainer());
+	}
+
+
+	/**
+	 * Test passing of a way which has nodes both inside and outside the area with completeWays =
+	 * true.
+	 */
+	@Test
+	public final void testProcessWayContainer6() {
+		Iterator<EntityContainer> ecIterator;
+
+		simpleCompleteWayFilter.process(new NodeContainer(inAreaWayNode1));
+		simpleCompleteWayFilter.process(new NodeContainer(inAreaWayNode2));
+		simpleCompleteWayFilter.process(new NodeContainer(outOfAreaWayNode1));
+		simpleCompleteWayFilter.process(new NodeContainer(outOfAreaWayNode2));
+		simpleCompleteWayFilter.process(new WayContainer(inOutWay));
+		simpleCompleteWayFilter.complete();
+
+		ecIterator = entityInspector.getProcessedEntities().iterator();
+		assertTrue(inAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0);
+		assertTrue(outOfAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0);
+		assertTrue(outOfAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0);
+		assertTrue(inOutWay.compareTo((Way)ecIterator.next().getEntity()) == 0
+		        && !ecIterator.hasNext());
+	}
+
+
+	/**
+	 * Test passing of a relation where all referenced members are strictly inside the filter area
+	 * (and completeRelations = false)
+	 */
+	@Test
+	public final void testProcessRelationContainer1() {
+		Iterator<EntityContainer> ecIterator;
+
+		simpleAreaFilter.process(new NodeContainer(inAreaWayNode1));
+		simpleAreaFilter.process(new NodeContainer(inAreaWayNode2));
+		simpleAreaFilter.process(new WayContainer(inAreaWay));
+		simpleAreaFilter.process(new RelationContainer(inAreaRelation));
+		simpleAreaFilter.complete();
+
+		ecIterator = entityInspector.getProcessedEntities().iterator();
+		assertTrue(inAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWay.compareTo((Way)ecIterator.next().getEntity()) == 0
+		        && inAreaRelation.compareTo((Relation)ecIterator.next().getEntity()) == 0
+		        && !ecIterator.hasNext());
+	}
+
+
+	/**
+	 * Test passing of a relation where all referenced members are strictly outside the filter area
+	 * (and completeRelations = false)
+	 */
+	@Test
+	public final void testProcessRelationContainer2() {
+		simpleAreaFilter.process(new NodeContainer(outOfAreaWayNode1));
+		simpleAreaFilter.process(new NodeContainer(outOfAreaWayNode2));
+		simpleAreaFilter.process(new WayContainer(outOfAreaWay));
+		simpleAreaFilter.process(new RelationContainer(outOfAreaRelation1));
+		simpleAreaFilter.complete();
+
+		assertNull(entityInspector.getLastEntityContainer());
+	}
+
+
+	/**
+	 * Test passing of a relation where referenced members are both inside and outside the filter
+	 * area (and completeRelations = false)
+	 */
+	@Test
+	public final void testProcessRelationContainer3() {
+		Iterator<EntityContainer> ecIterator;
+
+		simpleAreaFilter.process(new NodeContainer(inAreaWayNode1));
+		simpleAreaFilter.process(new NodeContainer(inAreaWayNode2));
+		simpleAreaFilter.process(new NodeContainer(outOfAreaWayNode1));
+		simpleAreaFilter.process(new NodeContainer(outOfAreaWayNode2));
+		simpleAreaFilter.process(new WayContainer(inOutWay));
+		simpleAreaFilter.process(new RelationContainer(inOutRelation1));
+		simpleAreaFilter.process(new RelationContainer(inOutRelation2));
+		simpleAreaFilter.complete();
+
+		ecIterator = entityInspector.getProcessedEntities().iterator();
+		assertTrue(inAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && mangledInOutWay1.compareTo((Way)ecIterator.next().getEntity()) == 0
+		        && mangledInOutRelation1.compareTo((Relation)ecIterator.next().getEntity()) == 0
+		        && mangledInOutRelation2.compareTo((Relation)ecIterator.next().getEntity()) == 0
+		        && !ecIterator.hasNext());
+	}
+
+
+	/**
+	 * Test passing of a relation where all referenced members are strictly inside the filter area
+	 * (and completeRelations = true)
+	 */
+	@Test
+	public final void testProcessRelationContainer4() {
+		Iterator<EntityContainer> ecIterator;
+
+		simpleCompleteRelationFilter.process(new NodeContainer(inAreaWayNode1));
+		simpleCompleteRelationFilter.process(new NodeContainer(inAreaWayNode2));
+		simpleCompleteRelationFilter.process(new WayContainer(inAreaWay));
+		simpleCompleteRelationFilter.process(new RelationContainer(inAreaRelation));
+		simpleCompleteRelationFilter.complete();
+
+		ecIterator = entityInspector.getProcessedEntities().iterator();
+		assertTrue(inAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWay.compareTo((Way)ecIterator.next().getEntity()) == 0
+		        && inAreaRelation.compareTo((Relation)ecIterator.next().getEntity()) == 0
+		        && !ecIterator.hasNext());
+	}
+
+
+	/**
+	 * Test passing of a relation where all referenced members are strictly outside the filter area
+	 * (and completeRelations = true)
+	 */
+	@Test
+	public final void testProcessRelationContainer5() {
+		simpleCompleteRelationFilter.process(new NodeContainer(outOfAreaWayNode1));
+		simpleCompleteRelationFilter.process(new NodeContainer(outOfAreaWayNode2));
+		simpleCompleteRelationFilter.process(new WayContainer(outOfAreaWay));
+		simpleCompleteRelationFilter.process(new RelationContainer(outOfAreaRelation1));
+		simpleCompleteRelationFilter.complete();
+
+		assertNull(entityInspector.getLastEntityContainer());
+	}
+
+
+	/**
+	 * Test passing of a relation where referenced members are both inside and outside the filter
+	 * area (and completeRelations = false)
+	 */
+	@Test
+	public final void testProcessRelationContainer6() {
+		Iterator<EntityContainer> ecIterator;
+
+		simpleCompleteRelationFilter.process(new NodeContainer(inAreaWayNode1));
+		simpleCompleteRelationFilter.process(new NodeContainer(inAreaWayNode2));
+		simpleCompleteRelationFilter.process(new NodeContainer(outOfAreaWayNode1));
+		simpleCompleteRelationFilter.process(new NodeContainer(outOfAreaWayNode2));
+		simpleCompleteRelationFilter.process(new WayContainer(inOutWay));
+		simpleCompleteRelationFilter.process(new RelationContainer(inOutRelation1));
+		simpleCompleteRelationFilter.process(new RelationContainer(inOutRelation2));
+		simpleCompleteRelationFilter.complete();
+
+		ecIterator = entityInspector.getProcessedEntities().iterator();
+		assertTrue(inAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && mangledInOutWay1.compareTo((Way)ecIterator.next().getEntity()) == 0
+		        && mangledCompleteInOutRelation1.compareTo((Relation)ecIterator.next().getEntity()) == 0
+		        && mangledInOutRelation2.compareTo((Relation)ecIterator.next().getEntity()) == 0
+		        && !ecIterator.hasNext());
+	}
+
+
+	/**
+	 * Test passing of a relation where referenced members are both inside and outside the filter
+	 * area (with completeWays = true and completeRelations = true)
+	 */
+	@Test
+	public final void testProcessRelationContainer7() {
+		Iterator<EntityContainer> ecIterator;
+
+		simpleCompleteWayRelationFilter.process(new NodeContainer(inAreaWayNode1));
+		simpleCompleteWayRelationFilter.process(new NodeContainer(inAreaWayNode2));
+		simpleCompleteWayRelationFilter.process(new NodeContainer(outOfAreaWayNode1));
+		simpleCompleteWayRelationFilter.process(new NodeContainer(outOfAreaWayNode2));
+		simpleCompleteWayRelationFilter.process(new WayContainer(inOutWay));
+		simpleCompleteWayRelationFilter.process(new RelationContainer(inOutRelation1));
+		simpleCompleteWayRelationFilter.process(new RelationContainer(inOutRelation2));
+		simpleCompleteWayRelationFilter.complete();
+
+		ecIterator = entityInspector.getProcessedEntities().iterator();
+		assertTrue(inAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && outOfAreaWayNode1.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && outOfAreaWayNode2.compareTo((Node)ecIterator.next().getEntity()) == 0
+		        && inOutWay.compareTo((Way)ecIterator.next().getEntity()) == 0
+		        && inOutRelation1.compareTo((Relation)ecIterator.next().getEntity()) == 0
+		        && inOutRelation2.compareTo((Relation)ecIterator.next().getEntity()) == 0
+		        && !ecIterator.hasNext());
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\core\filter\v0_5\AreaFilterTest.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/AreaFilterTestSuite.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/AreaFilterTestSuite.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/AreaFilterTestSuite.java	(revision 0)
@@ -0,0 +1,15 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.filter.v0_5;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+ 
+@RunWith(Suite.class)
+@Suite.SuiteClasses({
+  AreaFilterTest.class,
+  BoundingBoxFilterTest.class,
+  PolygonFilterTest.class,
+})
+public class AreaFilterTestSuite {
+    // Empty class; placeholder for suite annotations
+}
\ No newline at end of file

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\core\filter\v0_5\AreaFilterTestSuite.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/BoundingBoxFilterTest.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/BoundingBoxFilterTest.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/BoundingBoxFilterTest.java	(revision 0)
@@ -0,0 +1,164 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.filter.v0_5;
+
+import static org.junit.Assert.*;
+
+import java.util.Date;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
+import com.bretth.osmosis.core.domain.v0_5.Node;
+import com.bretth.osmosis.core.filter.common.IdTrackerType;
+import com.bretth.osmosis.test.task.SinkEntityInspector;
+
+/**
+ * @author Karl Newman
+ * 
+ */
+public class BoundingBoxFilterTest {
+
+	private SinkEntityInspector entityInspector;
+	private AreaFilter simpleAreaFilter;
+	private Bounds intersectingBounds;
+	private Bounds nonIntersectingBounds;
+	private Node inAreaNode;
+	private Node outOfAreaNode;
+	private Node edgeNodeEast;
+	private Node edgeNodeWest;
+	private Node edgeNodeNorth;
+	private Node edgeNodeSouth;
+
+
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@Before
+	public void setUp() throws Exception {
+		entityInspector = new SinkEntityInspector();
+		// simpleAreaFilter doesn't cross antimeridian; no complete ways or relations
+		simpleAreaFilter = new BoundingBoxFilter(
+		        IdTrackerType.IdList,
+		        -20,
+		        20,
+		        20,
+		        -20,
+		        false,
+		        false);
+		simpleAreaFilter.setSink(entityInspector);
+		intersectingBounds = new Bounds(30, 10, 30, 10, "intersecting");
+		nonIntersectingBounds = new Bounds(-30, -50, 10, -10, "nonintersecting");
+		inAreaNode = new Node(1234, new Date(), "OsmosisTest", 10, 10);
+		outOfAreaNode = new Node(1235, new Date(), "OsmosisTest", 30, 30);
+		edgeNodeEast = new Node(1236, new Date(), "OsmosisTest", 10, 20);
+		edgeNodeWest = new Node(1237, new Date(), "OsmosisTest", 10, -20);
+		edgeNodeNorth = new Node(1238, new Date(), "OsmosisTest", 20, 10);
+		edgeNodeSouth = new Node(1239, new Date(), "OsmosisTest", -20, 10);
+	}
+
+
+	/**
+	 * @throws java.lang.Exception
+	 */
+	@After
+	public void tearDown() throws Exception {
+		simpleAreaFilter.release();
+	}
+
+
+	/**
+	 * Test passing a Bounds which intersects the filter area.
+	 */
+	@Test
+	public final void testProcessBoundsContainer1() {
+		Bounds compareBounds;
+		simpleAreaFilter.process(new BoundsContainer(intersectingBounds));
+		simpleAreaFilter.complete();
+		compareBounds = (Bounds)entityInspector.getLastEntityContainer().getEntity();
+		assertTrue((Double.compare(compareBounds.getRight(), 20) == 0)
+		        && (Double.compare(compareBounds.getLeft(), 10) == 0)
+		        && (Double.compare(compareBounds.getTop(), 20) == 0)
+		        && (Double.compare(compareBounds.getBottom(), 10) == 0)
+		        && compareBounds.getOrigin().equals("intersecting"));
+	}
+
+
+	/**
+	 * Test the non-passing of a Bounds which does not intersect the filter area.
+	 */
+	@Test
+	public final void testProcessBoundsContainer2() {
+		simpleAreaFilter.process(new BoundsContainer(nonIntersectingBounds));
+		simpleAreaFilter.complete();
+		assertNull(entityInspector.getLastEntityContainer());
+	}
+
+
+	/**
+	 * Test a node inside the area.
+	 */
+	@Test
+	public final void testIsNodeWithinArea1() {
+		assertTrue(
+		        "Node lying inside filter area not considered inside area",
+		        simpleAreaFilter.isNodeWithinArea(inAreaNode));
+	}
+
+
+	/**
+	 * Test a node outside the area.
+	 */
+	@Test
+	public final void testIsNodeWithinArea2() {
+		assertFalse(
+		        "Node lying outside filter area not considered outside area",
+		        simpleAreaFilter.isNodeWithinArea(outOfAreaNode));
+	}
+
+
+	/**
+	 * Test a node on the East edge of the area.
+	 */
+	@Test
+	public final void testIsNodeWithinArea3() {
+		assertTrue(
+		        "Node lying on East edge of filter area not considered inside area",
+		        simpleAreaFilter.isNodeWithinArea(edgeNodeEast));
+	}
+
+
+	/**
+	 * Test a node on the West edge of the area.
+	 */
+	@Test
+	public final void testIsNodeWithinArea4() {
+		assertTrue(
+		        "Node lying on West edge of filter area not considered inside area",
+		        simpleAreaFilter.isNodeWithinArea(edgeNodeWest));
+	}
+
+
+	/**
+	 * Test a node on the North edge of the area.
+	 */
+	@Test
+	public final void testIsNodeWithinArea5() {
+		assertTrue(
+		        "Node lying on North edge of filter area not considered inside area",
+		        simpleAreaFilter.isNodeWithinArea(edgeNodeNorth));
+	}
+
+
+	/**
+	 * Test a node on the South edge of the area.
+	 */
+	@Test
+	public final void testIsNodeWithinArea6() {
+		assertTrue(
+		        "Node lying on South edge of filter area not considered inside area",
+		        simpleAreaFilter.isNodeWithinArea(edgeNodeSouth));
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\core\filter\v0_5\BoundingBoxFilterTest.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/PolygonFilterTest.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/PolygonFilterTest.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/PolygonFilterTest.java	(revision 0)
@@ -0,0 +1,130 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.filter.v0_5;
+
+import static org.junit.Assert.*;
+
+import java.io.File;
+import java.util.Date;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
+import com.bretth.osmosis.core.domain.v0_5.Node;
+import com.bretth.osmosis.core.filter.common.IdTrackerType;
+import com.bretth.osmosis.test.task.SinkEntityInspector;
+
+public class PolygonFilterTest {
+
+	File polygonFile;
+	private SinkEntityInspector entityInspector;
+	private AreaFilter polyAreaFilter;
+	private Bounds intersectingBounds;
+	private Bounds crossingIntersectingBounds;
+	private Bounds nonIntersectingBounds;
+	private Node inAreaNode;
+	private Node outOfAreaNode;
+	private Node edgeNode;
+
+
+	@Before
+	public void setUp() throws Exception {
+		polygonFile = new File("test/com/bretth/osmosis/core/filter/v0_5/testPolygon.txt");
+		entityInspector = new SinkEntityInspector();
+		// polyAreaFilter has a notch out of the Northeast corner.
+		polyAreaFilter = new PolygonFilter(IdTrackerType.IdList, polygonFile, false, false);
+		polyAreaFilter.setSink(entityInspector);
+		intersectingBounds = new Bounds(30, 0, 30, 0, "intersecting");
+		crossingIntersectingBounds = new Bounds(-10, 10, 30, -30, "crossing intersecting");
+		nonIntersectingBounds = new Bounds(30, 15, 30, 15, "nonintersecting");
+		inAreaNode = new Node(1234, new Date(), "OsmosisTest", 5, 10);
+		outOfAreaNode = new Node(1235, new Date(), "OsmosisTest", 15, 15);
+		edgeNode = new Node(1236, new Date(), "OsmosisTest", 15, 10);
+	}
+
+
+	@After
+	public void tearDown() throws Exception {
+		polyAreaFilter.release();
+	}
+
+
+	/**
+	 * Test passing a Bounds which intersects the filter area.
+	 */
+	@Test
+	public final void testProcessBoundsContainer1() {
+		Bounds compareBounds;
+		polyAreaFilter.process(new BoundsContainer(intersectingBounds));
+		polyAreaFilter.complete();
+		compareBounds = (Bounds)entityInspector.getLastEntityContainer().getEntity();
+		assertTrue((Double.compare(compareBounds.getRight(), 20) == 0)
+		        && (Double.compare(compareBounds.getLeft(), 0) == 0)
+		        && (Double.compare(compareBounds.getTop(), 20) == 0)
+		        && (Double.compare(compareBounds.getBottom(), 0) == 0)
+		        && compareBounds.getOrigin().equals("intersecting"));
+	}
+
+
+	/**
+	 * Test passing a Bounds which crosses the antimeredian and intersects the filter area.
+	 */
+	@Test
+	public final void testProcessBoundsContainer2() {
+		Bounds compareBounds;
+		polyAreaFilter.process(new BoundsContainer(crossingIntersectingBounds));
+		polyAreaFilter.complete();
+		compareBounds = (Bounds)entityInspector.getLastEntityContainer().getEntity();
+		assertTrue((Double.compare(compareBounds.getRight(), 20) == 0)
+		        && (Double.compare(compareBounds.getLeft(), -20) == 0)
+		        && (Double.compare(compareBounds.getTop(), 20) == 0)
+		        && (Double.compare(compareBounds.getBottom(), -20) == 0)
+		        && compareBounds.getOrigin().equals("crossing intersecting"));
+	}
+
+
+	/**
+	 * Test the non-passing of a Bounds which does not intersect the filter area.
+	 */
+	@Test
+	public final void testProcessBoundsContainer3() {
+		polyAreaFilter.process(new BoundsContainer(nonIntersectingBounds));
+		polyAreaFilter.complete();
+		assertNull(entityInspector.getLastEntityContainer());
+	}
+
+
+	/**
+	 * Test a Node that falls inside the filter area.
+	 */
+	@Test
+	public final void testIsNodeWithinArea1() {
+		assertTrue(
+		        "Node lying inside filter area not considered inside area.",
+		        polyAreaFilter.isNodeWithinArea(inAreaNode));
+	}
+
+
+	/**
+	 * Test a Node that falls outside the filter area (inside the notched-out area of the polygon).
+	 */
+	@Test
+	public final void testIsNodeWithinArea2() {
+		assertFalse(
+		        "Node lying outside filter area not considered outside area.",
+		        polyAreaFilter.isNodeWithinArea(outOfAreaNode));
+	}
+
+
+	/**
+	 * Test a Node that falls on the edge of the filter area.
+	 */
+	@Test
+	public final void testIsNodeWithinArea3() {
+		assertFalse(
+		        "Node lying on edge of filter area not considered inside area.",
+		        polyAreaFilter.isNodeWithinArea(edgeNode));
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\core\filter\v0_5\PolygonFilterTest.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/testPolygon.txt
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/testPolygon.txt	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/filter/v0_5/testPolygon.txt	(revision 0)
@@ -0,0 +1,11 @@
+testpolygon
+1
+    -0.2000000E+02     0.2000000E+02
+     0.1000000E+02     0.2000000E+02
+     0.1000000E+02     0.1000000E+02
+     0.2000000E+02     0.1000000E+02
+     0.2000000E+02    -0.2000000E+02
+    -0.2000000E+02    -0.2000000E+02
+    -0.2000000E+02     0.2000000E+02
+END
+END

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\core\filter\v0_5\testPolygon.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/xml/v0_5/impl/BoundsWriterTest.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/xml/v0_5/impl/BoundsWriterTest.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/xml/v0_5/impl/BoundsWriterTest.java	(revision 0)
@@ -0,0 +1,76 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.xml.v0_5.impl;
+
+import static org.junit.Assert.*;
+
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.StringWriter;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
+
+public class BoundsWriterTest {
+
+	private StringWriter testWriter;
+	private BufferedWriter testBufferedWriter;
+
+
+	@Before
+	public void setUp() throws Exception {
+		testWriter = new StringWriter();
+		testBufferedWriter = new BufferedWriter(testWriter);
+	}
+
+
+	@After
+	public void tearDown() throws Exception {
+		testBufferedWriter.close();
+		testWriter.close();
+	}
+
+
+	/**
+	 * Test writing out a normal Bounds element. 
+	 */
+	@Test
+	public final void testProcess1() {
+		BoundsWriter bw = new BoundsWriter("bound", 2);
+		bw.setWriter(testBufferedWriter);
+		bw.process(new Bounds(20.123456, -21.987654, 22.555555, -23.234567, "originstring"));
+		try {
+			testBufferedWriter.flush();
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("IOException");
+		}
+		// If this test fails, it could be because the regex has broken. There are a number of
+		// variations which are valid XML which this regex won't catch. It might need any number of
+		// \\s* to account for variable whitespace.
+		String regexMatch = "^\\s*<bound\\s*"
+		        + "box=['\"]-23.23457,-21.98765,22.55556,20.12346['\"]\\s*"
+		        + "origin=['\"]originstring['\"]/>\\s*$";
+		assertTrue(testWriter.toString().matches(regexMatch));
+	}
+
+	
+	/**
+	 * Test non-writing of a Bounds element with an empty origin string. 
+	 */
+	@Test
+	public final void testProcess2() {
+		BoundsWriter bw = new BoundsWriter("bound", 2);
+		bw.setWriter(testBufferedWriter);
+		bw.process(new Bounds(20.123456, -21.987654, 22.555555, -23.234567, ""));
+		try {
+			testBufferedWriter.flush();
+		} catch (IOException e) {
+			e.printStackTrace();
+			fail("IOException");
+		}
+		assertTrue(testWriter.toString().equals("")); // not written; empty string
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\core\xml\v0_5\impl\BoundsWriterTest.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/xml/v0_5/impl/OsmHandlerTest.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/xml/v0_5/impl/OsmHandlerTest.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/xml/v0_5/impl/OsmHandlerTest.java	(revision 0)
@@ -0,0 +1,231 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.core.xml.v0_5.impl;
+
+import static org.junit.Assert.*;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
+import com.bretth.osmosis.test.task.SinkEntityInspector;
+
+/**
+ * Not sure how to go about unit testing this. The individual parser classes seem to require a lot
+ * of infrastructure, so this test will just set up the full parser to parse an XML string and check
+ * the produced entities.
+ * 
+ * @author Karl Newman
+ * 
+ */
+public class OsmHandlerTest {
+
+	private SAXParser parser;
+	private SinkEntityInspector entityInspector;
+	private static final String OSM_PREFIX = "<osm version=\"0.5\">\n";
+	private static final String OSM_SUFFIX = "</osm>";
+
+
+	@Before
+	public void setUp() throws Exception {
+		entityInspector = new SinkEntityInspector();
+		try {
+			parser = SAXParserFactory.newInstance().newSAXParser();
+		} catch (ParserConfigurationException e) {
+			throw new OsmosisRuntimeException("Unable to create SAX Parser.", e);
+		} catch (SAXException e) {
+			throw new OsmosisRuntimeException("Unable to create SAX Parser.", e);
+		}
+	}
+
+
+	@After
+	public void tearDown() throws Exception {
+	}
+
+
+	private void parseString(String input) {
+		InputStream inputStream = null;
+		try {
+			inputStream = new ByteArrayInputStream(input.getBytes("UTF-8"));
+			parser.parse(inputStream, new OsmHandler(entityInspector, true));
+		} catch (UnsupportedEncodingException e) {
+			throw new OsmosisRuntimeException("String encoding exception", e);
+		} catch (SAXException e) {
+			throw new OsmosisRuntimeException("Parse exception", e);
+		} catch (IOException e) {
+			throw new OsmosisRuntimeException("IOException", e);
+		} finally {
+			try {
+				if (inputStream != null) {
+					inputStream.close();
+				}
+			} catch (IOException e) {
+				throw new OsmosisRuntimeException("IOException", e);
+			} finally {
+				inputStream = null;
+			}
+		}
+	}
+
+
+	@Test
+	public final void testEmptyDocument() {
+		parseString(OSM_PREFIX + OSM_SUFFIX);
+		assertNull(entityInspector.getLastEntityContainer());
+	}
+
+
+	/**
+	 * Test a normal, well-formed bound element.
+	 */
+	@Test
+	public final void testBoundElement1() {
+		parseString(OSM_PREFIX
+		        + "<bound box=\"-12.34567,-23.45678,34.56789,45.67891\""
+		        + " origin=\"someorigin\"/>"
+		        + OSM_SUFFIX);
+		Bounds b = (Bounds)entityInspector.getLastEntityContainer().getEntity();
+		assertTrue(Double.compare(b.getRight(), 45.67891) == 0
+		        && Double.compare(b.getLeft(), -23.45678) == 0
+		        && Double.compare(b.getTop(), 34.56789) == 0
+		        && Double.compare(b.getBottom(), -12.34567) == 0
+		        && b.getOrigin().equals("someorigin"));
+	}
+
+
+	/**
+	 * Test a malformed box attribute for a bound element.
+	 */
+	@Test(expected = OsmosisRuntimeException.class)
+	public final void testBoundElement2() {
+		parseString(OSM_PREFIX
+		        + "<bound box=\"-12.34567,-23.45678,34.56789\""
+		        + " origin=\"someorigin\"/>"
+		        + OSM_SUFFIX);
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test a missing box attribute of a bound element.
+	 */
+	@Test(expected = OsmosisRuntimeException.class)
+	public final void testBoundElement3() {
+		parseString(OSM_PREFIX + "<bound origin=\"someorigin\"/>" + OSM_SUFFIX);
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test a number parse error for a box attribute of a bound element.
+	 */
+	@Test(expected = OsmosisRuntimeException.class)
+	public final void testBoundElement4() {
+		parseString(OSM_PREFIX
+		        + "<bound box=\"-12..34567,-23.45678,34.56789,45.67891\""
+		        + " origin=\"someorigin\"/>"
+		        + OSM_SUFFIX);
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test a missing origin attribute of a bound element.
+	 */
+	@Test(expected = OsmosisRuntimeException.class)
+	public final void testBoundElement5() {
+		parseString(OSM_PREFIX
+		        + "<bound box=\"-12.34567,-23.45678,34.56789,45.67891\"/>"
+		        + OSM_SUFFIX);
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test an empty origin attribute of a bound element.
+	 */
+	@Test(expected = OsmosisRuntimeException.class)
+	public final void testBoundElement6() {
+		parseString(OSM_PREFIX
+		        + "<bound box=\"-12.34567,-23.45678,34.56789,45.67891\""
+		        + " origin=\"\"/>"
+		        + OSM_SUFFIX);
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test a repeated bound element.
+	 */
+	@Test(expected = OsmosisRuntimeException.class)
+	public final void testBoundElement7() {
+		parseString(OSM_PREFIX
+		        + "<bound box=\"-12.34567,-23.45678,34.56789,45.67891\""
+		        + " origin=\"someorigin\"/>"
+		        + "<bound box=\"-12.34567,-23.45678,34.56789,45.67891\""
+		        + " origin=\"someotherorigin\"/>"
+		        + OSM_SUFFIX);
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test a bound element occurring after a node element.
+	 */
+	@Test(expected = OsmosisRuntimeException.class)
+	public final void testBoundElement8() {
+		parseString(OSM_PREFIX
+		        + "<node id=\"12345\" user=\"OsmosisTest\" timestamp=\"2008-01-01T15:32:01\""
+		        + " lat=\"-12.34567\" lon=\"-23.45678\"/>"
+		        + "<bound box=\"-12.34567,-23.45678,34.56789,45.67891\""
+		        + " origin=\"someorigin\"/>"
+		        + OSM_SUFFIX);
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test a bound element occurring after a way element.
+	 */
+	@Test(expected = OsmosisRuntimeException.class)
+	public final void testBoundElement9() {
+		parseString(OSM_PREFIX
+		        + "<way id=\"12346\" user=\"OsmosisTest\" timestamp=\"2008-01-01T15:32:01\">"
+		        + "<nd ref=\"12345\"/>"
+		        + "<nd ref=\"12347\"/>"
+		        + "</way>"
+		        + "<bound box=\"-12.34567,-23.45678,34.56789,45.67891\""
+		        + " origin=\"someorigin\"/>"
+		        + OSM_SUFFIX);
+		fail("Expected to throw an exception");
+	}
+
+
+	/**
+	 * Test a bound element occurring after a relation element.
+	 */
+	@Test(expected = OsmosisRuntimeException.class)
+	public final void testBoundElement10() {
+		parseString(OSM_PREFIX
+		        + "<relation id=\"12348\" user=\"OsmosisTest\" timestamp=\"2008-01-01T15:32:01\">"
+		        + "<member ref=\"12345\" type=\"node\" role=\"node1\"/>"
+		        + "<member ref=\"12346\" type=\"way\" role=\"way1\"/>"
+		        + "</relation>"
+		        + "<bound box=\"-12.34567,-23.45678,34.56789,45.67891\""
+		        + " origin=\"someorigin\"/>"
+		        + OSM_SUFFIX);
+		fail("Expected to throw an exception");
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\core\xml\v0_5\impl\OsmHandlerTest.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/xml/v0_5/impl/OsmWriterTest.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/xml/v0_5/impl/OsmWriterTest.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/core/xml/v0_5/impl/OsmWriterTest.java	(revision 0)
@@ -0,0 +1,149 @@
+package com.bretth.osmosis.core.xml.v0_5.impl;
+
+import static org.junit.Assert.*;
+
+import java.io.BufferedWriter;
+import java.io.StringWriter;
+import java.util.Date;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.bretth.osmosis.core.OsmosisRuntimeException;
+import com.bretth.osmosis.core.container.v0_5.BoundsContainer;
+import com.bretth.osmosis.core.container.v0_5.NodeContainer;
+import com.bretth.osmosis.core.container.v0_5.RelationContainer;
+import com.bretth.osmosis.core.container.v0_5.WayContainer;
+import com.bretth.osmosis.core.domain.v0_5.Bounds;
+import com.bretth.osmosis.core.domain.v0_5.EntityType;
+import com.bretth.osmosis.core.domain.v0_5.Node;
+import com.bretth.osmosis.core.domain.v0_5.Relation;
+import com.bretth.osmosis.core.domain.v0_5.RelationMember;
+import com.bretth.osmosis.core.domain.v0_5.Tag;
+import com.bretth.osmosis.core.domain.v0_5.Way;
+import com.bretth.osmosis.core.domain.v0_5.WayNode;
+
+public class OsmWriterTest {
+
+	private StringWriter testWriter;
+	private BufferedWriter testBufferedWriter;
+	private OsmWriter testOsmWriter;
+
+
+	@Before
+	public void setUp() throws Exception {
+		testWriter = new StringWriter();
+		testBufferedWriter = new BufferedWriter(testWriter);
+		testOsmWriter = new OsmWriter("osm", 0);
+		testOsmWriter.setWriter(testBufferedWriter);
+	}
+
+
+	@After
+	public void tearDown() throws Exception {
+		testBufferedWriter.close();
+		testWriter.close();
+		testOsmWriter = null;
+	}
+
+
+	/**
+	 * Test processing a single Bounds entity.
+	 */
+	@Test
+	public final void testProcess1() {
+		testOsmWriter.process(new BoundsContainer(new Bounds("source")));
+		// Nothing to assert; just expect no exception
+	}
+
+
+	/**
+	 * Test processing a repeated Bounds entity.
+	 */
+	@Test(expected=OsmosisRuntimeException.class)
+	public final void testProcess2() {
+		testOsmWriter.process(new BoundsContainer(new Bounds("source")));
+		testOsmWriter.process(new BoundsContainer(new Bounds("source2")));
+		fail("Expected to throw an exception.");
+	}
+
+
+	/**
+	 * Test processing a Node entity.
+	 */
+	@Test
+	public final void testProcess3() {
+		testOsmWriter.process(new NodeContainer(new Node(1234, new Date(), "OsmosisTest", 20, 20)));
+		// Nothing to assert; just expect no exception
+	}
+
+
+	/**
+	 * Test processing a Bounds after a Node.
+	 */
+	@Test(expected=OsmosisRuntimeException.class)
+	public final void testProcess4() {
+		testOsmWriter.process(new NodeContainer(new Node(1234, new Date(), "OsmosisTest", 20, 20)));
+		testOsmWriter.process(new BoundsContainer(new Bounds("source")));
+		fail("Expected to throw an exception.");
+	}
+
+
+	/**
+	 * Test processing a Way.
+	 */
+	@Test
+	public final void testProcess6() {
+		Way testWay;
+		testWay = new Way(3456, new Date(), "OsmosisTest");
+		testWay.addWayNode(new WayNode(1234));
+		testWay.addWayNode(new WayNode(1235));
+		testWay.addTag(new Tag("test_key1", "test_value1"));
+		testOsmWriter.process(new WayContainer(testWay));
+		// Nothing to assert; just expect no exception
+	}
+
+
+	/**
+	 * Test processing a Bounds after a Way.
+	 */
+	@Test(expected=OsmosisRuntimeException.class)
+	public final void testProcess7() {
+		Way testWay;
+		testWay = new Way(3456, new Date(), "OsmosisTest");
+		testWay.addWayNode(new WayNode(1234));
+		testWay.addWayNode(new WayNode(1235));
+		testWay.addTag(new Tag("test_key1", "test_value1"));
+		testOsmWriter.process(new WayContainer(testWay));
+		testOsmWriter.process(new BoundsContainer(new Bounds("source")));
+	}
+
+
+	/**
+	 * Test processing a Relation.
+	 */
+	@Test
+	public final void testProcess8() {
+		Relation testRelation;
+		testRelation = new Relation(3456, new Date(), "OsmosisTest");
+		testRelation.addMember(new RelationMember(1234, EntityType.Node, "role1"));
+		testRelation.addTag(new Tag("test_key1", "test_value1"));
+		testOsmWriter.process(new RelationContainer(testRelation));
+		// Nothing to assert; just expect no exception
+	}
+
+	
+	/**
+	 * Test processing a Bounds after a Relation.
+	 */
+	@Test(expected=OsmosisRuntimeException.class)
+	public final void testProcess9() {
+		Relation testRelation;
+		testRelation = new Relation(3456, new Date(), "OsmosisTest");
+		testRelation.addMember(new RelationMember(1234, EntityType.Node, "role1"));
+		testRelation.addTag(new Tag("test_key1", "test_value1"));
+		testOsmWriter.process(new RelationContainer(testRelation));
+		testOsmWriter.process(new BoundsContainer(new Bounds("source")));
+	}
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\core\xml\v0_5\impl\OsmWriterTest.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

Index: C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/test/task/SinkEntityInspector.java
===================================================================
--- C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/test/task/SinkEntityInspector.java	(revision 0)
+++ C:/Documents and Settings/KNewman/workspace/Osmosis/test/com/bretth/osmosis/test/task/SinkEntityInspector.java	(revision 0)
@@ -0,0 +1,83 @@
+// License: GPL. Copyright 2007-2008 by Brett Henderson and other contributors.
+package com.bretth.osmosis.test.task;
+
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import com.bretth.osmosis.core.container.v0_5.EntityContainer;
+import com.bretth.osmosis.core.task.v0_5.Sink;
+
+/**
+ * Mock object for inspecting the resulting entities after passing through a pipeline task.
+ * 
+ * @author Karl Newman
+ */
+public class SinkEntityInspector implements Sink {
+
+	private List<EntityContainer> processedEntities;
+
+
+	private void initialize() {
+		if (processedEntities == null) {
+			processedEntities = new LinkedList<EntityContainer>();
+		}
+	}
+
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see com.bretth.osmosis.core.task.v0_5.Sink#complete()
+	 */
+	@Override
+	public void complete() {
+		// Nothing to do here
+	}
+
+
+	/**
+	 * Catch all passed entities and save them for later inspection.
+	 */
+	@Override
+	public void process(EntityContainer entityContainer) {
+		initialize();
+		processedEntities.add(entityContainer);
+	}
+
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see com.bretth.osmosis.core.task.v0_5.Sink#release()
+	 */
+	@Override
+	public void release() {
+		// Nothing to do here
+	}
+
+
+	/**
+	 * Shortcut method if you only care about the most recent EntityContainer.
+	 * 
+	 * @return the lastEntityContainer
+	 */
+	public EntityContainer getLastEntityContainer() {
+		initialize();
+		if (processedEntities.isEmpty()) {
+			return null;
+		} else
+			return processedEntities.get(processedEntities.size() - 1);
+	}
+
+
+	/**
+	 * Retrieve an Iterable of all the processed EntityContainers.
+	 * 
+	 * @return the processedEntities
+	 */
+	public Iterable<EntityContainer> getProcessedEntities() {
+		initialize();
+		return Collections.unmodifiableList(processedEntities);
+	}
+
+}

Property changes on: C:\Documents and Settings\KNewman\workspace\Osmosis\test\com\bretth\osmosis\test\task\SinkEntityInspector.java
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:keywords Author Id Revision
   + 

